import {
  signMessage,
  signTypedData
} from "./chunk-ZSBKCZVH.js";
import {
  getUser,
  signTransaction
} from "./chunk-Q7PVCN6P.js";
import {
  deploySmartAccount
} from "./chunk-G4S47F5F.js";
import {
  randomPrivateKey,
  sign
} from "./chunk-2JMEOC4X.js";
import "./chunk-5T45IMNW.js";
import {
  from,
  getSignPayload
} from "./chunk-YNTQV2T3.js";
import "./chunk-5DLV5WR6.js";
import {
  autoConnectCore,
  createConnectionManager
} from "./chunk-7FYKYXS6.js";
import {
  DefaultWalletConnectRequestHandlers,
  createWalletConnectClient,
  createWalletConnectSession,
  disconnectWalletConnectSession,
  getActiveWalletConnectSessions
} from "./chunk-GEA76TZZ.js";
import "./chunk-IBSKT6O2.js";
import "./chunk-LCFGTMVC.js";
import {
  getDefaultWallets
} from "./chunk-RIRC57DH.js";
import {
  createWallet,
  ecosystemWallet,
  inAppWallet,
  smartWallet,
  walletConnect
} from "./chunk-22KSTWL6.js";
import {
  getWalletBalance
} from "./chunk-5ESZ5ZHI.js";
import {
  authenticate,
  authenticateWithRedirect,
  getProfiles,
  getUserEmail,
  getUserPhoneNumber,
  linkProfile,
  preAuthenticate,
  unlinkProfile
} from "./chunk-YZB2WJYS.js";
import {
  createWalletEmitter,
  trackConnect
} from "./chunk-VLF66XAM.js";
import "./chunk-WHKSU3WO.js";
import "./chunk-QBAYKNNH.js";
import "./chunk-A527XV34.js";
import "./chunk-FUPOJN5U.js";
import "./chunk-NCVQ56IM.js";
import "./chunk-67YIWUOQ.js";
import {
  getWalletInfo
} from "./chunk-NAJGRCQ6.js";
import {
  autoConnectEip1193Wallet,
  connectEip1193Wallet
} from "./chunk-5TCCRZE2.js";
import {
  getInstalledWalletProviders,
  injectedProvider
} from "./chunk-NHH5L32Z.js";
import "./chunk-GUO62LYV.js";
import "./chunk-FHBAB4NL.js";
import "./chunk-57BDDLER.js";
import "./chunk-22VJJMQF.js";
import "./chunk-LZH3KM55.js";
import "./chunk-Y3VUZTEO.js";
import "./chunk-47A7GAXO.js";
import "./chunk-MTDFNONV.js";
import "./chunk-NACC2RRT.js";
import "./chunk-TBJ4CRRA.js";
import "./chunk-CKBH74JP.js";
import "./chunk-FUW7UPWG.js";
import {
  webLocalStorage
} from "./chunk-G4H2UJKK.js";
import "./chunk-LWBFBP2R.js";
import "./chunk-2GFN4PVI.js";
import "./chunk-HL4VUZA4.js";
import "./chunk-V2KTC3TQ.js";
import "./chunk-ZDBTTMOY.js";
import "./chunk-7WWFRKEP.js";
import "./chunk-F2HWAKON.js";
import "./chunk-BKSLBPLK.js";
import "./chunk-YCZ3YGMG.js";
import {
  sendTransaction
} from "./chunk-32UNHBSF.js";
import "./chunk-YQXA2AWL.js";
import "./chunk-RLZQZOTA.js";
import "./chunk-WQM2SOQQ.js";
import "./chunk-CQABUGWC.js";
import "./chunk-PHFEZCFB.js";
import "./chunk-V4DR3IRU.js";
import "./chunk-SWAFX6ND.js";
import {
  prepareTransaction
} from "./chunk-QGXAPRFG.js";
import "./chunk-SLZ3Y5V2.js";
import "./chunk-RNESBU4Y.js";
import "./chunk-DABXKW5Y.js";
import "./chunk-C3UIV4TQ.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import "./chunk-5LTEBNG6.js";
import "./chunk-BIVYGU57.js";
import {
  estimateGas
} from "./chunk-6AN5T5RL.js";
import "./chunk-MH6B2CTO.js";
import "./chunk-HAADYJEF.js";
import "./chunk-C67JNMHT.js";
import "./chunk-DV4XGEHR.js";
import {
  publicKeyToAddress
} from "./chunk-GRBRMOVF.js";
import "./chunk-6K2H5JDO.js";
import {
  getAddress
} from "./chunk-VNYBYIMU.js";
import "./chunk-OKXYG5CJ.js";
import "./chunk-LC6YL3ZA.js";
import "./chunk-CMZAKTPA.js";
import {
  getRpcClient
} from "./chunk-UOGLDG6G.js";
import "./chunk-2CIJO3V3.js";
import {
  hexToNumber,
  isHex,
  toHex
} from "./chunk-T7F22WNJ.js";
import {
  fromNumber
} from "./chunk-I364SXDL.js";
import {
  secp256k1
} from "./chunk-VDSMUIMW.js";
import "./chunk-HQ2F3JJN.js";
import "./chunk-QKQAKKUJ.js";
import {
  getCachedChain,
  getCachedChainIfExists
} from "./chunk-HQXXW4RM.js";
import "./chunk-MTFDOOBS.js";
import "./chunk-5V4VPUUX.js";
import "./chunk-PPP72TBL.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-5UJ7PIRT.js";
import {
  __export
} from "./chunk-256EKJAK.js";

// node_modules/thirdweb/dist/esm/wallets/private-key.js
function privateKeyToAccount(options) {
  const { client } = options;
  const privateKey = `0x${options.privateKey.replace(/^0x/, "")}`;
  const publicKey = toHex(secp256k1.getPublicKey(privateKey.slice(2), false));
  const address = publicKeyToAddress(publicKey);
  const account = {
    address: getAddress(address),
    sendTransaction: async (tx) => {
      const rpcRequest = getRpcClient({
        client,
        chain: getCachedChain(tx.chainId)
      });
      const signedTx = signTransaction({
        transaction: tx,
        privateKey
      });
      const transactionHash = await eth_sendRawTransaction(rpcRequest, signedTx);
      return {
        transactionHash
      };
    },
    signMessage: async ({ message }) => {
      return signMessage({
        message,
        privateKey
      });
    },
    signTypedData: async (_typedData) => {
      return signTypedData({
        ..._typedData,
        privateKey
      });
    },
    signTransaction: async (tx) => {
      return signTransaction({
        transaction: tx,
        privateKey
      });
    },
    signAuthorization: async (authorization) => {
      const signature = sign({
        payload: getSignPayload(authorization),
        privateKey
      });
      return from(authorization, { signature });
    }
  };
  return account;
}

// node_modules/thirdweb/dist/esm/wallets/utils/generateAccount.js
async function generateAccount(options) {
  const privateKey = toHex(secp256k1.utils.randomPrivateKey());
  return privateKeyToAccount({ privateKey, client: options.client });
}

// node_modules/thirdweb/dist/esm/wallets/getAllWalletsList.js
async function getAllWalletsList() {
  return (await import("./wallet-infos-AXAVWXOL.js")).default;
}

// node_modules/thirdweb/dist/esm/adapters/wallet-adapter.js
function createWalletAdapter(options) {
  const emitter = createWalletEmitter();
  let _chain = options.chain;
  return {
    id: "adapter",
    subscribe: emitter.subscribe,
    connect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    autoConnect: async () => {
      emitter.emit("onConnect", options);
      return options.adaptedAccount;
    },
    disconnect: async () => {
      await options.onDisconnect();
      emitter.emit("disconnect", void 0);
    },
    getAccount() {
      return options.adaptedAccount;
    },
    getChain() {
      const cachedChain = getCachedChainIfExists(_chain.id);
      _chain = cachedChain || _chain;
      return _chain;
    },
    getConfig() {
      return options;
    },
    switchChain: async (chain) => {
      await options.switchChain(chain);
      _chain = chain;
      emitter.emit("chainChanged", chain);
    }
  };
}

// node_modules/thirdweb/dist/esm/adapters/eip1193/index.js
var eip1193_exports = {};
__export(eip1193_exports, {
  fromProvider: () => fromProvider,
  toProvider: () => toProvider
});

// node_modules/thirdweb/dist/esm/adapters/eip1193/from-eip1193.js
function fromProvider(options) {
  const id = options.walletId ?? "adapter";
  const emitter = createWalletEmitter();
  let account = void 0;
  let chain = void 0;
  let provider = void 0;
  const getProvider = async (params) => {
    provider = typeof options.provider === "function" ? await options.provider(params) : options.provider;
    return provider;
  };
  const unsubscribeChain = emitter.subscribe("chainChanged", (newChain) => {
    chain = newChain;
  });
  function reset() {
    account = void 0;
    chain = void 0;
  }
  let handleDisconnect = async () => {
  };
  const unsubscribeDisconnect = emitter.subscribe("disconnect", () => {
    reset();
    unsubscribeChain();
    unsubscribeDisconnect();
  });
  emitter.subscribe("accountChanged", (_account) => {
    account = _account;
  });
  let handleSwitchChain = async (c) => {
    await (provider == null ? void 0 : provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: fromNumber(c.id) }]
    }));
  };
  return {
    id,
    subscribe: emitter.subscribe,
    getConfig: () => void 0,
    getChain() {
      if (!chain) {
        return void 0;
      }
      chain = getCachedChainIfExists(chain.id) || chain;
      return chain;
    },
    getAccount: () => account,
    connect: async (connectOptions) => {
      var _a;
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await connectEip1193Wallet({
        id,
        provider: await getProvider({ chainId: (_a = connectOptions.chain) == null ? void 0 : _a.id }),
        client: connectOptions.client,
        chain: connectOptions.chain,
        emitter
      });
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      emitter.emit("onConnect", connectOptions);
      trackConnect({
        client: connectOptions.client,
        walletType: id,
        walletAddress: account.address
      });
      return account;
    },
    autoConnect: async (connectOptions) => {
      var _a;
      const [connectedAccount, connectedChain, doDisconnect, doSwitchChain] = await autoConnectEip1193Wallet({
        id,
        provider: await getProvider({ chainId: (_a = connectOptions.chain) == null ? void 0 : _a.id }),
        emitter,
        chain: connectOptions.chain,
        client: connectOptions.client
      });
      account = connectedAccount;
      chain = connectedChain;
      handleDisconnect = doDisconnect;
      handleSwitchChain = doSwitchChain;
      emitter.emit("onConnect", connectOptions);
      trackConnect({
        client: connectOptions.client,
        walletType: id,
        walletAddress: account.address
      });
      return account;
    },
    disconnect: async () => {
      reset();
      await handleDisconnect();
      emitter.emit("disconnect", void 0);
    },
    switchChain: async (c) => {
      await handleSwitchChain(c);
      emitter.emit("chainChanged", c);
    }
  };
}

// node_modules/thirdweb/dist/esm/adapters/eip1193/to-eip1193.js
function toProvider(options) {
  const { chain, client, wallet, connectOverride } = options;
  const rpcClient = getRpcClient({ client, chain });
  return {
    on: wallet.subscribe,
    removeListener: () => {
    },
    request: async (request) => {
      if (request.method === "eth_sendTransaction") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        const result = await sendTransaction({
          transaction: prepareTransaction({
            ...request.params[0],
            chain,
            client
          }),
          account
        });
        return result.transactionHash;
      }
      if (request.method === "eth_estimateGas") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        return estimateGas({
          transaction: prepareTransaction({
            ...request.params[0],
            chain,
            client
          }),
          account
        });
      }
      if (request.method === "personal_sign") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        return account.signMessage({
          message: {
            raw: request.params[0]
          }
        });
      }
      if (request.method === "eth_signTypedData_v4") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        const data = JSON.parse(request.params[1]);
        return account.signTypedData(data);
      }
      if (request.method === "eth_accounts") {
        const account = wallet.getAccount();
        if (!account) {
          throw new Error("Account not connected");
        }
        return [account.address];
      }
      if (request.method === "eth_requestAccounts") {
        const account = connectOverride ? await connectOverride(wallet) : await wallet.connect({
          client
        });
        if (!account) {
          throw new Error("Unable to connect wallet");
        }
        return [account.address];
      }
      if (request.method === "wallet_switchEthereumChain" || request.method === "wallet_addEthereumChain") {
        const data = request.params[0];
        const chainIdHex = data.chainId;
        if (!chainIdHex) {
          throw new Error("Chain ID is required");
        }
        const chainId = isHex(chainIdHex) ? hexToNumber(chainIdHex) : chainIdHex;
        const chain2 = getCachedChain(chainId);
        return wallet.switchChain(chain2);
      }
      return rpcClient(request);
    }
  };
}

// node_modules/thirdweb/dist/esm/wallets/connection/autoConnect.js
async function autoConnect(props) {
  const wallets = props.wallets || getDefaultWallets(props);
  const manager = createConnectionManager(webLocalStorage);
  const result = await autoConnectCore({
    storage: webLocalStorage,
    props: {
      ...props,
      wallets
    },
    createWalletFn: createWallet,
    getInstalledWallets: () => {
      const specifiedWalletIds = new Set(wallets.map((x) => x.id));
      const installedWallets = getInstalledWalletProviders().filter((x) => !specifiedWalletIds.has(x.info.rdns)).map((x) => createWallet(x.info.rdns));
      return installedWallets;
    },
    manager
  });
  return result;
}
export {
  DefaultWalletConnectRequestHandlers,
  eip1193_exports as EIP1193,
  authenticate,
  authenticateWithRedirect,
  autoConnect,
  createWallet,
  createWalletAdapter,
  createWalletConnectClient,
  createWalletConnectSession,
  deploySmartAccount,
  disconnectWalletConnectSession,
  ecosystemWallet,
  inAppWallet as embeddedWallet,
  generateAccount,
  getActiveWalletConnectSessions,
  getAllWalletsList,
  getProfiles,
  getUser,
  getUserEmail,
  getUserPhoneNumber,
  getWalletBalance,
  getWalletInfo,
  inAppWallet,
  injectedProvider,
  linkProfile,
  preAuthenticate,
  privateKeyToAccount as privateKeyAccount,
  privateKeyToAccount,
  randomPrivateKey,
  smartWallet,
  unlinkProfile,
  walletConnect
};
//# sourceMappingURL=thirdweb_wallets.js.map
