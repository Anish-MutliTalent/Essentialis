{
  "version": 3,
  "sources": ["../../ox/core/PersonalMessage.ts", "../../thirdweb/src/utils/signatures/sign-message.ts", "../../thirdweb/src/utils/signatures/sign-typed-data.ts"],
  "sourcesContent": ["import type * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\n\n/**\n * Encodes a personal sign message in [ERC-191 format](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e): `0x19 ‖ \"Ethereum Signed Message:\\n\" + message.length ‖ message`.\n *\n * @example\n * ```ts twoslash\n * import { Hex, PersonalMessage } from 'ox'\n *\n * const data = PersonalMessage.encode(Hex.fromString('hello world'))\n * // @log: '0x19457468657265756d205369676e6564204d6573736167653a0a313168656c6c6f20776f726c64'\n * // @log: (0x19 ‖ 'Ethereum Signed Message:\\n11' ‖ 'hello world')\n * ```\n *\n * @param data - The data to encode.\n * @returns The encoded personal sign message.\n */\nexport function encode(data: Hex.Hex | Bytes.Bytes): Hex.Hex {\n  const message = Hex.from(data)\n  return Hex.concat(\n    // Personal Sign Format: `0x19 ‖ \"Ethereum Signed Message:\\n\" ‖ message.length ‖ message`\n    '0x19',\n    Hex.fromString('Ethereum Signed Message:\\n' + Hex.size(message)),\n    message,\n  )\n}\n\nexport declare namespace encode {\n  type ErrorType =\n    | Hex.concat.ErrorType\n    | Hex.from.ErrorType\n    | Hex.fromString.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Gets the payload to use for signing an [ERC-191 formatted](https://eips.ethereum.org/EIPS/eip-191#version-0x45-e) personal message.\n *\n * @example\n * ```ts twoslash\n * import { Hex, PersonalMessage, Secp256k1 } from 'ox'\n *\n * const payload = PersonalMessage.getSignPayload(Hex.fromString('hello world')) // [!code focus]\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param data - The data to get the sign payload for.\n * @returns The payload to use for signing.\n */\nexport function getSignPayload(data: Hex.Hex | Bytes.Bytes): Hex.Hex {\n  return Hash.keccak256(encode(data))\n}\n\nexport declare namespace getSignPayload {\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | encode.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import * as ox__Hex from \"ox/Hex\";\nimport * as ox__PersonalMessage from \"ox/PersonalMessage\";\nimport * as ox__Secp256k1 from \"ox/Secp256k1\";\nimport * as ox__Signature from \"ox/Signature\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport type { Hex } from \"../encoding/hex.js\";\nimport type { Prettify } from \"../type-utils.js\";\n\ntype Message = Prettify<\n  | string\n  | {\n      raw: Hex | Uint8Array;\n    }\n>;\nexport type SignMessageOptions = {\n  message: Message;\n  privateKey: Hex;\n};\n\n/**\n * Signs a string message with a given private key.\n * @param options The options for signing.\n * @param options.message The message to be signed as a string or object containing raw hex or bytes\n * @param options.privateKey The private key to be used\n * @returns The signature as a hex string\n * @example\n * ```ts\n * import { signMessage } from \"thirdweb/utils\";\n * signMessage({\n *   message: \"Hello, world!\",\n *   privateKey: \"0x...\",\n * });\n * ```\n * @utils\n */\nexport function signMessage({ message, privateKey }: SignMessageOptions): Hex;\n\n/**\n * Signs a string message with a given account.\n * @param options The options for signing.\n * @param options.message The message to be signed as a string or object containing raw hex or bytes\n * @param options.account The account to be used\n * @returns The signature as a hex string\n * @example\n * ```ts\n * import { signMessage } from \"thirdweb/utils\";\n * await signMessage({\n *   message: \"Hello, world!\",\n *   account\n * });\n * ```\n * @walletUtils\n */\nexport function signMessage({\n  message,\n  account,\n}: { message: Message; account: Account }): Promise<Hex>;\n\nexport function signMessage(\n  options: SignMessageOptions | { message: Message; account: Account },\n): Hex | Promise<Hex> {\n  if (\"privateKey\" in options) {\n    const payload = ox__PersonalMessage.getSignPayload(\n      typeof options.message === \"object\"\n        ? options.message.raw\n        : ox__Hex.fromString(options.message),\n    );\n\n    const signature = ox__Secp256k1.sign({\n      payload,\n      privateKey: options.privateKey,\n    });\n    return ox__Signature.toHex(signature);\n  }\n  if (\"account\" in options) {\n    const { message, account } = options;\n    return account.signMessage({ message });\n  }\n  throw new Error(\"Either privateKey or account is required\");\n}\n", "import * as ox__Hex from \"ox/Hex\";\nimport * as ox__Secp256k1 from \"ox/Secp256k1\";\nimport * as ox__Signature from \"ox/Signature\";\nimport * as ox__TypedData from \"ox/TypedData\";\nimport type { Hex } from \"../encoding/hex.js\";\n\nexport type SignTypedDataOptions<\n  typedData extends\n    | ox__TypedData.TypedData\n    | Record<string, unknown> = ox__TypedData.TypedData,\n  primaryType extends keyof typedData | \"EIP712Domain\" = keyof typedData,\n> = ox__TypedData.Definition<typedData, primaryType> & {\n  privateKey: Hex;\n};\n\n/**\n * Signs a typed data object with a given private key according to EIP712.\n * @param options The typed data is passed within options alongside the private key\n * @param options.privateKey The private key to sign the typed data with\n * @returns The signature as a hex string\n * @example\n * ```ts\n * import { signTypedData } from \"thirdweb/utils\";\n * signTypedData({\n *   privateKey: \"0x...\",\n *   ...typedData\n * });\n * ```\n * @utils\n */\nexport function signTypedData<\n  const typedData extends ox__TypedData.TypedData | Record<string, unknown>,\n  primaryType extends keyof typedData | \"EIP712Domain\",\n>(options: SignTypedDataOptions<typedData, primaryType>): Hex {\n  const { privateKey, ...typedData } =\n    options as unknown as SignTypedDataOptions;\n\n  if (typeof typedData.domain?.chainId === \"string\") {\n    typedData.domain.chainId = ox__Hex.toNumber(typedData.domain.chainId);\n  }\n\n  const payload = ox__TypedData.getSignPayload(typedData);\n\n  const signature = ox__Secp256k1.sign({\n    payload,\n    privateKey,\n  });\n\n  return ox__Signature.toHex(signature);\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;AAoBM,SAAU,OAAO,MAA2B;AAChD,QAAM,UAAc,KAAK,IAAI;AAC7B,SAAW;;IAET;IACI,WAAW,+BAAmC,KAAK,OAAO,CAAC;IAC/D;EAAO;AAEX;AAyBM,SAAUA,gBAAe,MAA2B;AACxD,SAAY,UAAU,OAAO,IAAI,CAAC;AACpC;;;ACGM,SAAU,YACd,SAAoE;AAEpE,MAAI,gBAAgB,SAAS;AAC3B,UAAM,UAA8BC,gBAClC,OAAO,QAAQ,YAAY,WACvB,QAAQ,QAAQ,MACR,WAAW,QAAQ,OAAO,CAAC;AAGzC,UAAM,YAA0B,KAAK;MACnC;MACA,YAAY,QAAQ;KACrB;AACD,WAAqB,MAAM,SAAS;EACtC;AACA,MAAI,aAAa,SAAS;AACxB,UAAM,EAAE,SAAS,QAAO,IAAK;AAC7B,WAAO,QAAQ,YAAY,EAAE,QAAO,CAAE;EACxC;AACA,QAAM,IAAI,MAAM,0CAA0C;AAC5D;;;ACjDM,SAAU,cAGd,SAAqD;AAjCvD;AAkCE,QAAM,EAAE,YAAY,GAAG,UAAS,IAC9B;AAEF,MAAI,SAAO,eAAU,WAAV,mBAAkB,aAAY,UAAU;AACjD,cAAU,OAAO,UAAkB,SAAS,UAAU,OAAO,OAAO;EACtE;AAEA,QAAM,UAAwB,eAAe,SAAS;AAEtD,QAAM,YAA0B,KAAK;IACnC;IACA;GACD;AAED,SAAqB,MAAM,SAAS;AACtC;",
  "names": ["getSignPayload", "getSignPayload"]
}
