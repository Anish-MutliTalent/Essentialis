{
  "version": 3,
  "sources": ["../../thirdweb/src/rpc/actions/eth_gasPrice.ts", "../../thirdweb/src/rpc/actions/eth_getBlockByNumber.ts", "../../thirdweb/src/rpc/actions/eth_maxPriorityFeePerGas.ts", "../../thirdweb/node_modules/abitype/src/version.ts", "../../thirdweb/node_modules/abitype/src/errors.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/abiItem.ts", "../../thirdweb/node_modules/abitype/src/regex.ts", "../../thirdweb/node_modules/abitype/src/human-readable/runtime/signatures.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/abiParameter.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/signature.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/struct.ts", "../../thirdweb/node_modules/abitype/src/human-readable/errors/splitParameters.ts", "../../thirdweb/node_modules/abitype/src/human-readable/runtime/cache.ts", "../../thirdweb/node_modules/abitype/src/human-readable/runtime/utils.ts", "../../thirdweb/node_modules/abitype/src/human-readable/runtime/structs.ts", "../../thirdweb/node_modules/abitype/src/human-readable/parseAbiItem.ts", "../../thirdweb/node_modules/abitype/src/human-readable/formatAbiParameter.ts", "../../thirdweb/node_modules/abitype/src/human-readable/formatAbiParameters.ts", "../../thirdweb/node_modules/abitype/src/human-readable/formatAbiItem.ts", "../../thirdweb/node_modules/abitype/src/human-readable/formatAbi.ts", "../../thirdweb/node_modules/abitype/src/human-readable/parseAbi.ts", "../../thirdweb/src/gas/get-gas-price.ts", "../../thirdweb/src/utils/promise/resolve-promised-value.ts", "../../thirdweb/src/gas/op-gas-fee-reducer.ts", "../../thirdweb/src/contract/actions/resolve-abi.ts", "../../thirdweb/src/transaction/extract-error.ts", "../../thirdweb/src/transaction/actions/estimate-gas.ts", "../../thirdweb/src/gas/fee-data.ts"],
  "sourcesContent": ["import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the current gas price from the Ethereum network.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to the gas price as a bigint.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_gasPrice } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const gasPrice = await eth_gasPrice(rpcRequest);\n * ```\n */\nexport async function eth_gasPrice(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const result = await request({\n    method: \"eth_gasPrice\",\n  });\n  return hexToBigInt(result);\n}\n", "import {\n  type BlockTag,\n  type EIP1193RequestFn,\n  type EIP1474Methods,\n  type GetBlockReturnType,\n  formatBlock,\n} from \"viem\";\nimport { numberToHex } from \"../../utils/encoding/hex.js\";\n\ntype GetBlockParameters<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = \"latest\",\n> = {\n  /** Whether or not to include transaction data in the response. */\n  includeTransactions?: TIncludeTransactions;\n} & (\n  | {\n      /** The block number. */\n      blockNumber?: bigint;\n      blockTag?: never;\n    }\n  | {\n      blockNumber?: never;\n      /**\n       * The block tag.\n       * default: 'latest'\n       */\n      blockTag?: TBlockTag | BlockTag;\n    }\n);\n\n/**\n * Retrieves a block by its number or tag from the Ethereum blockchain.\n * @param request - The EIP1193 request function.\n * @param params - The parameters for retrieving the block.\n * @returns A promise that resolves to the requested block.\n * @throws An error if the block is not found.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_getBlockByNumber } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const block = await eth_getBlockByNumber(rpcRequest, {\n *  blockNumber: 123456,\n *  includeTransactions: true,\n * });\n * ```\n */\nexport async function eth_getBlockByNumber<\n  TIncludeTransactions extends boolean = false,\n  TBlockTag extends BlockTag = \"latest\",\n>(\n  request: EIP1193RequestFn<EIP1474Methods>,\n  params: GetBlockParameters<TIncludeTransactions, TBlockTag>,\n): Promise<GetBlockReturnType<undefined, TIncludeTransactions, TBlockTag>> {\n  const blockTag = params.blockTag ?? \"latest\";\n  const includeTransactions = params.includeTransactions ?? false;\n  const blockNumberHex =\n    params.blockNumber !== undefined\n      ? numberToHex(params.blockNumber)\n      : undefined;\n\n  const block = await request({\n    method: \"eth_getBlockByNumber\",\n    params: [blockNumberHex || blockTag, includeTransactions],\n  });\n  if (!block) {\n    throw new Error(\"Block not found\");\n  }\n  return formatBlock(block) as GetBlockReturnType<\n    undefined,\n    TIncludeTransactions,\n    TBlockTag\n  >;\n}\n", "import type { EIP1193RequestFn, EIP1474Methods } from \"viem\";\nimport { hexToBigInt } from \"../../utils/encoding/hex.js\";\n\n/**\n * Retrieves the maximum priority fee per gas from the Ethereum network.\n * @param request - The EIP1193 request function.\n * @returns A promise that resolves to a bigint representing the maximum priority fee per gas.\n * @rpc\n * @example\n * ```ts\n * import { getRpcClient, eth_maxPriorityFeePerGas } from \"thirdweb/rpc\";\n * const rpcRequest = getRpcClient({ client, chain });\n * const maxPriorityFeePerGas = await eth_maxPriorityFeePerGas(rpcRequest);\n * ```\n */\nexport async function eth_maxPriorityFeePerGas(\n  request: EIP1193RequestFn<EIP1474Methods>,\n): Promise<bigint> {\n  const result = await request({\n    method: \"eth_maxPriorityFeePerGas\",\n  });\n  return hexToBigInt(result);\n}\n", "export const version = '1.0.8'\n", "import type { OneOf, Pretty } from './types.js'\nimport { version } from './version.js'\n\ntype BaseErrorArgs = Pretty<\n  {\n    docsPath?: string | undefined\n    metaMessages?: string[] | undefined\n  } & OneOf<{ details?: string | undefined } | { cause?: BaseError | Error }>\n>\n\nexport class BaseError extends Error {\n  details: string\n  docsPath?: string | undefined\n  metaMessages?: string[] | undefined\n  shortMessage: string\n\n  override name = 'AbiTypeError'\n\n  constructor(shortMessage: string, args: BaseErrorArgs = {}) {\n    const details =\n      args.cause instanceof BaseError\n        ? args.cause.details\n        : args.cause?.message\n          ? args.cause.message\n          : args.details!\n    const docsPath =\n      args.cause instanceof BaseError\n        ? args.cause.docsPath || args.docsPath\n        : args.docsPath\n    const message = [\n      shortMessage || 'An error occurred.',\n      '',\n      ...(args.metaMessages ? [...args.metaMessages, ''] : []),\n      ...(docsPath ? [`Docs: https://abitype.dev${docsPath}`] : []),\n      ...(details ? [`Details: ${details}`] : []),\n      `Version: abitype@${version}`,\n    ].join('\\n')\n\n    super(message)\n\n    if (args.cause) this.cause = args.cause\n    this.details = details\n    this.docsPath = docsPath\n    this.metaMessages = args.metaMessages\n    this.shortMessage = shortMessage\n  }\n}\n", "import { BaseError } from '../../errors.js'\n\nexport class InvalidAbiItemError extends BaseError {\n  override name = 'InvalidAbiItemError'\n\n  constructor({ signature }: { signature: string | object }) {\n    super('Failed to parse ABI item.', {\n      details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,\n      docsPath: '/api/human#parseabiitem-1',\n    })\n  }\n}\n\nexport class UnknownTypeError extends BaseError {\n  override name = 'UnknownTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [\n        `Type \"${type}\" is not a valid ABI type. Perhaps you forgot to include a struct signature?`,\n      ],\n    })\n  }\n}\n\nexport class UnknownSolidityTypeError extends BaseError {\n  override name = 'UnknownSolidityTypeError'\n\n  constructor({ type }: { type: string }) {\n    super('Unknown type.', {\n      metaMessages: [`Type \"${type}\" is not a valid ABI type.`],\n    })\n  }\n}\n", "// TODO: This looks cool. Need to check the performance of `new RegExp` versus defined inline though.\n// https://twitter.com/GabrielVergnaud/status/1622906834343366657\nexport function execTyped<type>(regex: RegExp, string: string) {\n  const match = regex.exec(string)\n  return match?.groups as type | undefined\n}\n\n// `bytes<M>`: binary type of `M` bytes, `0 < M <= 32`\n// https://regexr.com/6va55\nexport const bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/\n\n// `(u)int<M>`: (un)signed integer type of `M` bits, `0 < M <= 256`, `M % 8 == 0`\n// https://regexr.com/6v8hp\nexport const integerRegex =\n  /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/\n\nexport const isTupleRegex = /^\\(.+?\\).*?$/\n", "import type { AbiStateMutability } from '../../abi.js'\nimport { execTyped } from '../../regex.js'\nimport type {\n  EventModifier,\n  FunctionModifier,\n  Modifier,\n} from '../types/signatures.js'\n\n// https://regexr.com/7gmok\nconst errorSignatureRegex =\n  /^error (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isErrorSignature(signature: string) {\n  return errorSignatureRegex.test(signature)\n}\nexport function execErrorSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    errorSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmoq\nconst eventSignatureRegex =\n  /^event (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)$/\nexport function isEventSignature(signature: string) {\n  return eventSignatureRegex.test(signature)\n}\nexport function execEventSignature(signature: string) {\n  return execTyped<{ name: string; parameters: string }>(\n    eventSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/7gmot\nconst functionSignatureRegex =\n  /^function (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*)\\((?<parameters>.*?)\\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns\\s?\\((?<returns>.*?)\\))?$/\nexport function isFunctionSignature(signature: string) {\n  return functionSignatureRegex.test(signature)\n}\nexport function execFunctionSignature(signature: string) {\n  return execTyped<{\n    name: string\n    parameters: string\n    stateMutability?: AbiStateMutability\n    returns?: string\n  }>(functionSignatureRegex, signature)\n}\n\n// https://regexr.com/7gmp3\nconst structSignatureRegex =\n  /^struct (?<name>[a-zA-Z$_][a-zA-Z0-9$_]*) \\{(?<properties>.*?)\\}$/\nexport function isStructSignature(signature: string) {\n  return structSignatureRegex.test(signature)\n}\nexport function execStructSignature(signature: string) {\n  return execTyped<{ name: string; properties: string }>(\n    structSignatureRegex,\n    signature,\n  )\n}\n\n// https://regexr.com/78u01\nconst constructorSignatureRegex =\n  /^constructor\\((?<parameters>.*?)\\)(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isConstructorSignature(signature: string) {\n  return constructorSignatureRegex.test(signature)\n}\nexport function execConstructorSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(constructorSignatureRegex, signature)\n}\n\n// https://regexr.com/7srtn\nconst fallbackSignatureRegex =\n  /^fallback\\(\\) external(?:\\s(?<stateMutability>payable{1}))?$/\nexport function isFallbackSignature(signature: string) {\n  return fallbackSignatureRegex.test(signature)\n}\nexport function execFallbackSignature(signature: string) {\n  return execTyped<{\n    parameters: string\n    stateMutability?: Extract<AbiStateMutability, 'payable'>\n  }>(fallbackSignatureRegex, signature)\n}\n\n// https://regexr.com/78u1k\nconst receiveSignatureRegex = /^receive\\(\\) external payable$/\nexport function isReceiveSignature(signature: string) {\n  return receiveSignatureRegex.test(signature)\n}\n\nexport const modifiers = new Set<Modifier>([\n  'memory',\n  'indexed',\n  'storage',\n  'calldata',\n])\nexport const eventModifiers = new Set<EventModifier>(['indexed'])\nexport const functionModifiers = new Set<FunctionModifier>([\n  'calldata',\n  'memory',\n  'storage',\n])\n", "import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\nimport type { Modifier } from '../types/signatures.js'\n\nexport class InvalidAbiParameterError extends BaseError {\n  override name = 'InvalidAbiParameterError'\n\n  constructor({ param }: { param: string | object }) {\n    super('Failed to parse ABI parameter.', {\n      details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,\n      docsPath: '/api/human#parseabiparameter-1',\n    })\n  }\n}\n\nexport class InvalidAbiParametersError extends BaseError {\n  override name = 'InvalidAbiParametersError'\n\n  constructor({ params }: { params: string | object }) {\n    super('Failed to parse ABI parameters.', {\n      details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,\n      docsPath: '/api/human#parseabiparameters-1',\n    })\n  }\n}\n\nexport class InvalidParameterError extends BaseError {\n  override name = 'InvalidParameterError'\n\n  constructor({ param }: { param: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n    })\n  }\n}\n\nexport class SolidityProtectedKeywordError extends BaseError {\n  override name = 'SolidityProtectedKeywordError'\n\n  constructor({ param, name }: { param: string; name: string }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `\"${name}\" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`,\n      ],\n    })\n  }\n}\n\nexport class InvalidModifierError extends BaseError {\n  override name = 'InvalidModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidFunctionModifierError extends BaseError {\n  override name = 'InvalidFunctionModifierError'\n\n  constructor({\n    param,\n    type,\n    modifier,\n  }: {\n    param: string\n    type?: AbiItemType | 'struct' | undefined\n    modifier: Modifier\n  }) {\n    super('Invalid ABI parameter.', {\n      details: param,\n      metaMessages: [\n        `Modifier \"${modifier}\" not allowed${\n          type ? ` in \"${type}\" type` : ''\n        }.`,\n        `Data location can only be specified for array, struct, or mapping types, but \"${modifier}\" was given.`,\n      ],\n    })\n  }\n}\n\nexport class InvalidAbiTypeParameterError extends BaseError {\n  override name = 'InvalidAbiTypeParameterError'\n\n  constructor({\n    abiParameter,\n  }: {\n    abiParameter: AbiParameter & { indexed?: boolean | undefined }\n  }) {\n    super('Invalid ABI parameter.', {\n      details: JSON.stringify(abiParameter, null, 2),\n      metaMessages: ['ABI parameter type is invalid.'],\n    })\n  }\n}\n", "import type { AbiItemType } from '../../abi.js'\nimport { BaseError } from '../../errors.js'\n\nexport class InvalidSignatureError extends BaseError {\n  override name = 'InvalidSignatureError'\n\n  constructor({\n    signature,\n    type,\n  }: {\n    signature: string\n    type: AbiItemType | 'struct'\n  }) {\n    super(`Invalid ${type} signature.`, {\n      details: signature,\n    })\n  }\n}\n\nexport class UnknownSignatureError extends BaseError {\n  override name = 'UnknownSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Unknown signature.', {\n      details: signature,\n    })\n  }\n}\n\nexport class InvalidStructSignatureError extends BaseError {\n  override name = 'InvalidStructSignatureError'\n\n  constructor({ signature }: { signature: string }) {\n    super('Invalid struct signature.', {\n      details: signature,\n      metaMessages: ['No properties exist.'],\n    })\n  }\n}\n", "import { BaseError } from '../../errors.js'\n\nexport class CircularReferenceError extends BaseError {\n  override name = 'CircularReferenceError'\n\n  constructor({ type }: { type: string }) {\n    super('Circular reference detected.', {\n      metaMessages: [`Struct \"${type}\" is a circular reference.`],\n    })\n  }\n}\n", "import { BaseError } from '../../errors.js'\n\nexport class InvalidParenthesisError extends BaseError {\n  override name = 'InvalidParenthesisError'\n\n  constructor({ current, depth }: { current: string; depth: number }) {\n    super('Unbalanced parentheses.', {\n      metaMessages: [\n        `\"${current.trim()}\" has too many ${\n          depth > 0 ? 'opening' : 'closing'\n        } parentheses.`,\n      ],\n      details: `Depth \"${depth}\"`,\n    })\n  }\n}\n", "import type { AbiItemType, AbiParameter } from '../../abi.js'\nimport type { StructLookup } from '../types/structs.js'\n\n/**\n * Gets {@link parameterCache} cache key namespaced by {@link type}. This prevents parameters from being accessible to types that don't allow them (e.g. `string indexed foo` not allowed outside of `type: 'event'`).\n * @param param ABI parameter string\n * @param type ABI parameter type\n * @returns Cache key for {@link parameterCache}\n */\nexport function getParameterCacheKey(\n  param: string,\n  type?: AbiItemType | 'struct',\n  structs?: StructLookup,\n) {\n  let structKey = ''\n  if (structs)\n    for (const struct of Object.entries(structs)) {\n      if (!struct) continue\n      let propertyKey = ''\n      for (const property of struct[1]) {\n        propertyKey += `[${property.type}${property.name ? `:${property.name}` : ''}]`\n      }\n      structKey += `(${struct[0]}{${propertyKey}})`\n    }\n  if (type) return `${type}:${param}${structKey}`\n  return param\n}\n\n/**\n * Basic cache seeded with common ABI parameter strings.\n *\n * **Note: When seeding more parameters, make sure you benchmark performance. The current number is the ideal balance between performance and having an already existing cache.**\n */\nexport const parameterCache = new Map<\n  string,\n  AbiParameter & { indexed?: boolean }\n>([\n  // Unnamed\n  ['address', { type: 'address' }],\n  ['bool', { type: 'bool' }],\n  ['bytes', { type: 'bytes' }],\n  ['bytes32', { type: 'bytes32' }],\n  ['int', { type: 'int256' }],\n  ['int256', { type: 'int256' }],\n  ['string', { type: 'string' }],\n  ['uint', { type: 'uint256' }],\n  ['uint8', { type: 'uint8' }],\n  ['uint16', { type: 'uint16' }],\n  ['uint24', { type: 'uint24' }],\n  ['uint32', { type: 'uint32' }],\n  ['uint64', { type: 'uint64' }],\n  ['uint96', { type: 'uint96' }],\n  ['uint112', { type: 'uint112' }],\n  ['uint160', { type: 'uint160' }],\n  ['uint192', { type: 'uint192' }],\n  ['uint256', { type: 'uint256' }],\n\n  // Named\n  ['address owner', { type: 'address', name: 'owner' }],\n  ['address to', { type: 'address', name: 'to' }],\n  ['bool approved', { type: 'bool', name: 'approved' }],\n  ['bytes _data', { type: 'bytes', name: '_data' }],\n  ['bytes data', { type: 'bytes', name: 'data' }],\n  ['bytes signature', { type: 'bytes', name: 'signature' }],\n  ['bytes32 hash', { type: 'bytes32', name: 'hash' }],\n  ['bytes32 r', { type: 'bytes32', name: 'r' }],\n  ['bytes32 root', { type: 'bytes32', name: 'root' }],\n  ['bytes32 s', { type: 'bytes32', name: 's' }],\n  ['string name', { type: 'string', name: 'name' }],\n  ['string symbol', { type: 'string', name: 'symbol' }],\n  ['string tokenURI', { type: 'string', name: 'tokenURI' }],\n  ['uint tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint8 v', { type: 'uint8', name: 'v' }],\n  ['uint256 balance', { type: 'uint256', name: 'balance' }],\n  ['uint256 tokenId', { type: 'uint256', name: 'tokenId' }],\n  ['uint256 value', { type: 'uint256', name: 'value' }],\n\n  // Indexed\n  [\n    'event:address indexed from',\n    { type: 'address', name: 'from', indexed: true },\n  ],\n  ['event:address indexed to', { type: 'address', name: 'to', indexed: true }],\n  [\n    'event:uint indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n  [\n    'event:uint256 indexed tokenId',\n    { type: 'uint256', name: 'tokenId', indexed: true },\n  ],\n])\n", "import type {\n  AbiItemType,\n  AbiType,\n  SolidityArray,\n  SolidityBytes,\n  SolidityString,\n  SolidityTuple,\n} from '../../abi.js'\nimport {\n  bytesRegex,\n  execTyped,\n  integerRegex,\n  isTupleRegex,\n} from '../../regex.js'\nimport { UnknownSolidityTypeError } from '../errors/abiItem.js'\nimport {\n  InvalidFunctionModifierError,\n  InvalidModifierError,\n  InvalidParameterError,\n  SolidityProtectedKeywordError,\n} from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  UnknownSignatureError,\n} from '../errors/signature.js'\nimport { InvalidParenthesisError } from '../errors/splitParameters.js'\nimport type { FunctionModifier, Modifier } from '../types/signatures.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { getParameterCacheKey, parameterCache } from './cache.js'\nimport {\n  eventModifiers,\n  execConstructorSignature,\n  execErrorSignature,\n  execEventSignature,\n  execFallbackSignature,\n  execFunctionSignature,\n  functionModifiers,\n  isConstructorSignature,\n  isErrorSignature,\n  isEventSignature,\n  isFallbackSignature,\n  isFunctionSignature,\n  isReceiveSignature,\n} from './signatures.js'\n\nexport function parseSignature(signature: string, structs: StructLookup = {}) {\n  if (isFunctionSignature(signature))\n    return parseFunctionSignature(signature, structs)\n\n  if (isEventSignature(signature))\n    return parseEventSignature(signature, structs)\n\n  if (isErrorSignature(signature))\n    return parseErrorSignature(signature, structs)\n\n  if (isConstructorSignature(signature))\n    return parseConstructorSignature(signature, structs)\n\n  if (isFallbackSignature(signature)) return parseFallbackSignature(signature)\n\n  if (isReceiveSignature(signature))\n    return {\n      type: 'receive',\n      stateMutability: 'payable',\n    }\n\n  throw new UnknownSignatureError({ signature })\n}\n\nexport function parseFunctionSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execFunctionSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'function' })\n\n  const inputParams = splitParameters(match.parameters)\n  const inputs = []\n  const inputLength = inputParams.length\n  for (let i = 0; i < inputLength; i++) {\n    inputs.push(\n      parseAbiParameter(inputParams[i]!, {\n        modifiers: functionModifiers,\n        structs,\n        type: 'function',\n      }),\n    )\n  }\n\n  const outputs = []\n  if (match.returns) {\n    const outputParams = splitParameters(match.returns)\n    const outputLength = outputParams.length\n    for (let i = 0; i < outputLength; i++) {\n      outputs.push(\n        parseAbiParameter(outputParams[i]!, {\n          modifiers: functionModifiers,\n          structs,\n          type: 'function',\n        }),\n      )\n    }\n  }\n\n  return {\n    name: match.name,\n    type: 'function',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs,\n    outputs,\n  }\n}\n\nexport function parseEventSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execEventSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'event' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, {\n        modifiers: eventModifiers,\n        structs,\n        type: 'event',\n      }),\n    )\n  return { name: match.name, type: 'event', inputs: abiParameters }\n}\n\nexport function parseErrorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execErrorSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'error' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'error' }),\n    )\n  return { name: match.name, type: 'error', inputs: abiParameters }\n}\n\nexport function parseConstructorSignature(\n  signature: string,\n  structs: StructLookup = {},\n) {\n  const match = execConstructorSignature(signature)\n  if (!match)\n    throw new InvalidSignatureError({ signature, type: 'constructor' })\n\n  const params = splitParameters(match.parameters)\n  const abiParameters = []\n  const length = params.length\n  for (let i = 0; i < length; i++)\n    abiParameters.push(\n      parseAbiParameter(params[i]!, { structs, type: 'constructor' }),\n    )\n  return {\n    type: 'constructor',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n    inputs: abiParameters,\n  }\n}\n\nexport function parseFallbackSignature(signature: string) {\n  const match = execFallbackSignature(signature)\n  if (!match) throw new InvalidSignatureError({ signature, type: 'fallback' })\n\n  return {\n    type: 'fallback',\n    stateMutability: match.stateMutability ?? 'nonpayable',\n  }\n}\n\nconst abiParameterWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst abiParameterWithTupleRegex =\n  /^\\((?<type>.+?)\\)(?<array>(?:\\[\\d*?\\])+?)?(?:\\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\\s(?<name>[a-zA-Z$_][a-zA-Z0-9$_]*))?$/\nconst dynamicIntegerRegex = /^u?int$/\n\ntype ParseOptions = {\n  modifiers?: Set<Modifier>\n  structs?: StructLookup\n  type?: AbiItemType | 'struct'\n}\n\nexport function parseAbiParameter(param: string, options?: ParseOptions) {\n  // optional namespace cache by `type`\n  const parameterCacheKey = getParameterCacheKey(\n    param,\n    options?.type,\n    options?.structs,\n  )\n  if (parameterCache.has(parameterCacheKey))\n    return parameterCache.get(parameterCacheKey)!\n\n  const isTuple = isTupleRegex.test(param)\n  const match = execTyped<{\n    array?: string\n    modifier?: Modifier\n    name?: string\n    type: string\n  }>(\n    isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex,\n    param,\n  )\n  if (!match) throw new InvalidParameterError({ param })\n\n  if (match.name && isSolidityKeyword(match.name))\n    throw new SolidityProtectedKeywordError({ param, name: match.name })\n\n  const name = match.name ? { name: match.name } : {}\n  const indexed = match.modifier === 'indexed' ? { indexed: true } : {}\n  const structs = options?.structs ?? {}\n  let type: string\n  let components = {}\n  if (isTuple) {\n    type = 'tuple'\n    const params = splitParameters(match.type)\n    const components_ = []\n    const length = params.length\n    for (let i = 0; i < length; i++) {\n      // remove `modifiers` from `options` to prevent from being added to tuple components\n      components_.push(parseAbiParameter(params[i]!, { structs }))\n    }\n    components = { components: components_ }\n  } else if (match.type in structs) {\n    type = 'tuple'\n    components = { components: structs[match.type] }\n  } else if (dynamicIntegerRegex.test(match.type)) {\n    type = `${match.type}256`\n  } else {\n    type = match.type\n    if (!(options?.type === 'struct') && !isSolidityType(type))\n      throw new UnknownSolidityTypeError({ type })\n  }\n\n  if (match.modifier) {\n    // Check if modifier exists, but is not allowed (e.g. `indexed` in `functionModifiers`)\n    if (!options?.modifiers?.has?.(match.modifier))\n      throw new InvalidModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n\n    // Check if resolved `type` is valid if there is a function modifier\n    if (\n      functionModifiers.has(match.modifier as FunctionModifier) &&\n      !isValidDataLocation(type, !!match.array)\n    )\n      throw new InvalidFunctionModifierError({\n        param,\n        type: options?.type,\n        modifier: match.modifier,\n      })\n  }\n\n  const abiParameter = {\n    type: `${type}${match.array ?? ''}`,\n    ...name,\n    ...indexed,\n    ...components,\n  }\n  parameterCache.set(parameterCacheKey, abiParameter)\n  return abiParameter\n}\n\n// s/o latika for this\nexport function splitParameters(\n  params: string,\n  result: string[] = [],\n  current = '',\n  depth = 0,\n): readonly string[] {\n  const length = params.trim().length\n  // biome-ignore lint/correctness/noUnreachable: recursive\n  for (let i = 0; i < length; i++) {\n    const char = params[i]\n    const tail = params.slice(i + 1)\n    switch (char) {\n      case ',':\n        return depth === 0\n          ? splitParameters(tail, [...result, current.trim()])\n          : splitParameters(tail, result, `${current}${char}`, depth)\n      case '(':\n        return splitParameters(tail, result, `${current}${char}`, depth + 1)\n      case ')':\n        return splitParameters(tail, result, `${current}${char}`, depth - 1)\n      default:\n        return splitParameters(tail, result, `${current}${char}`, depth)\n    }\n  }\n\n  if (current === '') return result\n  if (depth !== 0) throw new InvalidParenthesisError({ current, depth })\n\n  result.push(current.trim())\n  return result\n}\n\nexport function isSolidityType(\n  type: string,\n): type is Exclude<AbiType, SolidityTuple | SolidityArray> {\n  return (\n    type === 'address' ||\n    type === 'bool' ||\n    type === 'function' ||\n    type === 'string' ||\n    bytesRegex.test(type) ||\n    integerRegex.test(type)\n  )\n}\n\nconst protectedKeywordsRegex =\n  /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/\n\n/** @internal */\nexport function isSolidityKeyword(name: string) {\n  return (\n    name === 'address' ||\n    name === 'bool' ||\n    name === 'function' ||\n    name === 'string' ||\n    name === 'tuple' ||\n    bytesRegex.test(name) ||\n    integerRegex.test(name) ||\n    protectedKeywordsRegex.test(name)\n  )\n}\n\n/** @internal */\nexport function isValidDataLocation(\n  type: string,\n  isArray: boolean,\n): type is Exclude<\n  AbiType,\n  SolidityString | Extract<SolidityBytes, 'bytes'> | SolidityArray\n> {\n  return isArray || type === 'bytes' || type === 'string' || type === 'tuple'\n}\n", "import type { AbiParameter } from '../../abi.js'\nimport { execTyped, isTupleRegex } from '../../regex.js'\nimport { UnknownTypeError } from '../errors/abiItem.js'\nimport { InvalidAbiTypeParameterError } from '../errors/abiParameter.js'\nimport {\n  InvalidSignatureError,\n  InvalidStructSignatureError,\n} from '../errors/signature.js'\nimport { CircularReferenceError } from '../errors/struct.js'\nimport type { StructLookup } from '../types/structs.js'\nimport { execStructSignature, isStructSignature } from './signatures.js'\nimport { isSolidityType, parseAbiParameter } from './utils.js'\n\nexport function parseStructs(signatures: readonly string[]) {\n  // Create \"shallow\" version of each struct (and filter out non-structs or invalid structs)\n  const shallowStructs: StructLookup = {}\n  const signaturesLength = signatures.length\n  for (let i = 0; i < signaturesLength; i++) {\n    const signature = signatures[i]!\n    if (!isStructSignature(signature)) continue\n\n    const match = execStructSignature(signature)\n    if (!match) throw new InvalidSignatureError({ signature, type: 'struct' })\n\n    const properties = match.properties.split(';')\n\n    const components: AbiParameter[] = []\n    const propertiesLength = properties.length\n    for (let k = 0; k < propertiesLength; k++) {\n      const property = properties[k]!\n      const trimmed = property.trim()\n      if (!trimmed) continue\n      const abiParameter = parseAbiParameter(trimmed, {\n        type: 'struct',\n      })\n      components.push(abiParameter)\n    }\n\n    if (!components.length) throw new InvalidStructSignatureError({ signature })\n    shallowStructs[match.name] = components\n  }\n\n  // Resolve nested structs inside each parameter\n  const resolvedStructs: StructLookup = {}\n  const entries = Object.entries(shallowStructs)\n  const entriesLength = entries.length\n  for (let i = 0; i < entriesLength; i++) {\n    const [name, parameters] = entries[i]!\n    resolvedStructs[name] = resolveStructs(parameters, shallowStructs)\n  }\n\n  return resolvedStructs\n}\n\nconst typeWithoutTupleRegex =\n  /^(?<type>[a-zA-Z$_][a-zA-Z0-9$_]*)(?<array>(?:\\[\\d*?\\])+?)?$/\n\nfunction resolveStructs(\n  abiParameters: readonly (AbiParameter & { indexed?: true })[],\n  structs: StructLookup,\n  ancestors = new Set<string>(),\n) {\n  const components: AbiParameter[] = []\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    const isTuple = isTupleRegex.test(abiParameter.type)\n    if (isTuple) components.push(abiParameter)\n    else {\n      const match = execTyped<{ array?: string; type: string }>(\n        typeWithoutTupleRegex,\n        abiParameter.type,\n      )\n      if (!match?.type) throw new InvalidAbiTypeParameterError({ abiParameter })\n\n      const { array, type } = match\n      if (type in structs) {\n        if (ancestors.has(type)) throw new CircularReferenceError({ type })\n\n        components.push({\n          ...abiParameter,\n          type: `tuple${array ?? ''}`,\n          components: resolveStructs(\n            structs[type] ?? [],\n            structs,\n            new Set([...ancestors, type]),\n          ),\n        })\n      } else {\n        if (isSolidityType(type)) components.push(abiParameter)\n        else throw new UnknownTypeError({ type })\n      }\n    }\n  }\n\n  return components\n}\n", "import type { Abi } from '../abi.js'\nimport type { Narrow } from '../narrow.js'\nimport type { Error, Filter } from '../types.js'\nimport { InvalidAbiItemError } from './errors/abiItem.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signature, Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * type Result = ParseAbiItem<'function balanceOf(address owner) view returns (uint256)'>\n * //   ^? type Result = { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * type Result = ParseAbiItem<\n *   // ^? type Result = { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   ['function foo(Baz bar) view returns (string)', 'struct Baz { string name; }']\n * >\n */\nexport type ParseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n> =\n  | (signature extends string\n      ? string extends signature\n        ? Abi[number]\n        : signature extends Signature<signature> // Validate signature\n          ? ParseSignature<signature>\n          : never\n      : never)\n  | (signature extends readonly string[]\n      ? string[] extends signature\n        ? Abi[number] // Return generic Abi item since type was no inferrable\n        : signature extends Signatures<signature> // Validate signature\n          ? ParseStructs<signature> extends infer structs\n            ? {\n                [key in keyof signature]: ParseSignature<\n                  signature[key] extends string ? signature[key] : never,\n                  structs\n                >\n              } extends infer mapped extends readonly unknown[]\n              ? // Filter out `never` since those are structs\n                Filter<mapped, never>[0] extends infer result\n                ? result extends undefined // convert `undefined` to `never` (e.g. `ParseAbiItem<['struct Foo { string name; }']>`)\n                  ? never\n                  : result\n                : never\n              : never\n            : never\n          : never\n      : never)\n\n/**\n * Parses human-readable ABI item (e.g. error, event, function) into {@link Abi} item\n *\n * @param signature - Human-readable ABI item\n * @returns Parsed {@link Abi} item\n *\n * @example\n * const abiItem = parseAbiItem('function balanceOf(address owner) view returns (uint256)')\n * //    ^? const abiItem: { name: \"balanceOf\"; type: \"function\"; stateMutability: \"view\";...\n *\n * @example\n * const abiItem = parseAbiItem([\n *   //  ^? const abiItem: { name: \"foo\"; type: \"function\"; stateMutability: \"view\"; inputs:...\n *   'function foo(Baz bar) view returns (string)',\n *   'struct Baz { string name; }',\n * ])\n */\nexport function parseAbiItem<\n  signature extends string | readonly string[] | readonly unknown[],\n>(\n  signature: Narrow<signature> &\n    (\n      | (signature extends string\n          ? string extends signature\n            ? unknown\n            : Signature<signature>\n          : never)\n      | (signature extends readonly string[]\n          ? signature extends readonly [] // empty array\n            ? Error<'At least one signature required.'>\n            : string[] extends signature\n              ? unknown\n              : Signatures<signature>\n          : never)\n    ),\n): ParseAbiItem<signature> {\n  let abiItem: ParseAbiItem<signature> | undefined\n  if (typeof signature === 'string')\n    abiItem = parseSignature(signature) as ParseAbiItem<signature>\n  else {\n    const structs = parseStructs(signature as readonly string[])\n    const length = signature.length as number\n    for (let i = 0; i < length; i++) {\n      const signature_ = (signature as readonly string[])[i]!\n      if (isStructSignature(signature_)) continue\n      abiItem = parseSignature(signature_, structs) as ParseAbiItem<signature>\n      break\n    }\n  }\n\n  if (!abiItem) throw new InvalidAbiItemError({ signature })\n  return abiItem as ParseAbiItem<signature>\n}\n", "import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport { execTyped } from '../regex.js'\nimport type { IsNarrowable, Join } from '../types.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * type Result = FormatAbiParameter<{ type: 'address'; name: 'from'; }>\n * //   ^? type Result = 'address from'\n */\nexport type FormatAbiParameter<\n  abiParameter extends AbiParameter | AbiEventParameter,\n> = abiParameter extends {\n  name?: infer name extends string\n  type: `tuple${infer array}`\n  components: infer components extends readonly AbiParameter[]\n  indexed?: infer indexed extends boolean\n}\n  ? FormatAbiParameter<\n      {\n        type: `(${Join<\n          {\n            [key in keyof components]: FormatAbiParameter<\n              {\n                type: components[key]['type']\n              } & (IsNarrowable<components[key]['name'], string> extends true\n                ? { name: components[key]['name'] }\n                : unknown) &\n                (components[key] extends { components: readonly AbiParameter[] }\n                  ? { components: components[key]['components'] }\n                  : unknown)\n            >\n          },\n          ', '\n        >})${array}`\n      } & (IsNarrowable<name, string> extends true ? { name: name } : unknown) &\n        (IsNarrowable<indexed, boolean> extends true\n          ? { indexed: indexed }\n          : unknown)\n    >\n  : `${abiParameter['type']}${abiParameter extends { indexed: true }\n      ? ' indexed'\n      : ''}${abiParameter['name'] extends infer name extends string\n      ? name extends ''\n        ? ''\n        : ` ${AssertName<name>}`\n      : ''}`\n\n// https://regexr.com/7f7rv\nconst tupleRegex = /^tuple(?<array>(\\[(\\d*)\\])*)$/\n\n/**\n * Formats {@link AbiParameter} to human-readable ABI parameter.\n *\n * @param abiParameter - ABI parameter\n * @returns Human-readable ABI parameter\n *\n * @example\n * const result = formatAbiParameter({ type: 'address', name: 'from' })\n * //    ^? const result: 'address from'\n */\nexport function formatAbiParameter<\n  const abiParameter extends AbiParameter | AbiEventParameter,\n>(abiParameter: abiParameter): FormatAbiParameter<abiParameter> {\n  type Result = FormatAbiParameter<abiParameter>\n\n  let type = abiParameter.type\n  if (tupleRegex.test(abiParameter.type) && 'components' in abiParameter) {\n    type = '('\n    const length = abiParameter.components.length as number\n    for (let i = 0; i < length; i++) {\n      const component = abiParameter.components[i]!\n      type += formatAbiParameter(component)\n      if (i < length - 1) type += ', '\n    }\n    const result = execTyped<{ array?: string }>(tupleRegex, abiParameter.type)\n    type += `)${result?.array ?? ''}`\n    return formatAbiParameter({\n      ...abiParameter,\n      type,\n    }) as Result\n  }\n  // Add `indexed` to type if in `abiParameter`\n  if ('indexed' in abiParameter && abiParameter.indexed)\n    type = `${type} indexed`\n  // Return human-readable ABI parameter\n  if (abiParameter.name) return `${type} ${abiParameter.name}` as Result\n  return type as Result\n}\n", "import type { AbiEventParameter, AbiParameter } from '../abi.js'\nimport type { Join } from '../types.js'\nimport {\n  type FormatAbiParameter,\n  formatAbiParameter,\n} from './formatAbiParameter.js'\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameter.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * type Result = FormatAbiParameters<[\n *   // ^? type Result = 'address from, uint256 tokenId'\n *   { type: 'address'; name: 'from'; },\n *   { type: 'uint256'; name: 'tokenId'; },\n * ]>\n */\nexport type FormatAbiParameters<\n  abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n> = Join<\n  {\n    [key in keyof abiParameters]: FormatAbiParameter<abiParameters[key]>\n  },\n  ', '\n>\n\n/**\n * Formats {@link AbiParameter}s to human-readable ABI parameters.\n *\n * @param abiParameters - ABI parameters\n * @returns Human-readable ABI parameters\n *\n * @example\n * const result = formatAbiParameters([\n *   //  ^? const result: 'address from, uint256 tokenId'\n *   { type: 'address', name: 'from' },\n *   { type: 'uint256', name: 'tokenId' },\n * ])\n */\nexport function formatAbiParameters<\n  const abiParameters extends readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ],\n>(abiParameters: abiParameters): FormatAbiParameters<abiParameters> {\n  let params = ''\n  const length = abiParameters.length\n  for (let i = 0; i < length; i++) {\n    const abiParameter = abiParameters[i]!\n    params += formatAbiParameter(abiParameter)\n    if (i !== length - 1) params += ', '\n  }\n  return params as FormatAbiParameters<abiParameters>\n}\n", "import type {\n  Abi,\n  AbiConstructor,\n  AbiError,\n  AbiEvent,\n  AbiEventParameter,\n  AbiFallback,\n  AbiFunction,\n  AbiParameter,\n  AbiReceive,\n  AbiStateMutability,\n} from '../abi.js'\nimport {\n  type FormatAbiParameters as FormatAbiParameters_,\n  formatAbiParameters,\n} from './formatAbiParameters.js'\nimport type { AssertName } from './types/signatures.js'\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport type FormatAbiItem<abiItem extends Abi[number]> =\n  Abi[number] extends abiItem\n    ? string\n    :\n        | (abiItem extends AbiFunction\n            ? AbiFunction extends abiItem\n              ? string\n              : `function ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends Exclude<\n                  AbiStateMutability,\n                  'nonpayable'\n                >\n                  ? ` ${abiItem['stateMutability']}`\n                  : ''}${abiItem['outputs']['length'] extends 0\n                  ? ''\n                  : ` returns (${FormatAbiParameters<abiItem['outputs']>})`}`\n            : never)\n        | (abiItem extends AbiEvent\n            ? AbiEvent extends abiItem\n              ? string\n              : `event ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiError\n            ? AbiError extends abiItem\n              ? string\n              : `error ${AssertName<abiItem['name']>}(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})`\n            : never)\n        | (abiItem extends AbiConstructor\n            ? AbiConstructor extends abiItem\n              ? string\n              : `constructor(${FormatAbiParameters<\n                  abiItem['inputs']\n                >})${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiFallback\n            ? AbiFallback extends abiItem\n              ? string\n              : `fallback() external${abiItem['stateMutability'] extends 'payable'\n                  ? ' payable'\n                  : ''}`\n            : never)\n        | (abiItem extends AbiReceive\n            ? AbiReceive extends abiItem\n              ? string\n              : 'receive() external payable'\n            : never)\n\ntype FormatAbiParameters<\n  abiParameters extends readonly (AbiParameter | AbiEventParameter)[],\n> = abiParameters['length'] extends 0\n  ? ''\n  : FormatAbiParameters_<\n      abiParameters extends readonly [\n        AbiParameter | AbiEventParameter,\n        ...(readonly (AbiParameter | AbiEventParameter)[]),\n      ]\n        ? abiParameters\n        : never\n    >\n\n/**\n * Formats ABI item (e.g. error, event, function) into human-readable ABI item\n *\n * @param abiItem - ABI item\n * @returns Human-readable ABI item\n */\nexport function formatAbiItem<const abiItem extends Abi[number]>(\n  abiItem: abiItem,\n): FormatAbiItem<abiItem> {\n  type Result = FormatAbiItem<abiItem>\n  type Params = readonly [\n    AbiParameter | AbiEventParameter,\n    ...(readonly (AbiParameter | AbiEventParameter)[]),\n  ]\n\n  if (abiItem.type === 'function')\n    return `function ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})${\n      abiItem.stateMutability && abiItem.stateMutability !== 'nonpayable'\n        ? ` ${abiItem.stateMutability}`\n        : ''\n    }${\n      abiItem.outputs?.length\n        ? ` returns (${formatAbiParameters(abiItem.outputs as Params)})`\n        : ''\n    }`\n  if (abiItem.type === 'event')\n    return `event ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'error')\n    return `error ${abiItem.name}(${formatAbiParameters(\n      abiItem.inputs as Params,\n    )})`\n  if (abiItem.type === 'constructor')\n    return `constructor(${formatAbiParameters(abiItem.inputs as Params)})${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }`\n  if (abiItem.type === 'fallback')\n    return `fallback() external${\n      abiItem.stateMutability === 'payable' ? ' payable' : ''\n    }` as Result\n  return 'receive() external payable' as Result\n}\n", "import type { Abi } from '../abi.js'\nimport { type FormatAbiItem, formatAbiItem } from './formatAbiItem.js'\n\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param abi - ABI\n * @returns Human-readable ABI\n */\nexport type FormatAbi<abi extends Abi | readonly unknown[]> = Abi extends abi\n  ? readonly string[]\n  : abi extends readonly []\n    ? never\n    : abi extends Abi\n      ? {\n          [key in keyof abi]: FormatAbiItem<abi[key]>\n        }\n      : readonly string[]\n\n/**\n * Parses JSON ABI into human-readable ABI\n *\n * @param abi - ABI\n * @returns Human-readable ABI\n */\nexport function formatAbi<const abi extends Abi | readonly unknown[]>(\n  abi: abi,\n): FormatAbi<abi> {\n  const signatures = []\n  const length = abi.length\n  for (let i = 0; i < length; i++) {\n    const abiItem = abi[i]!\n    const signature = formatAbiItem(abiItem as Abi[number])\n    signatures.push(signature)\n  }\n  return signatures as unknown as FormatAbi<abi>\n}\n", "import type { Abi } from '../abi.js'\nimport type { Error, Filter } from '../types.js'\nimport { isStructSignature } from './runtime/signatures.js'\nimport { parseStructs } from './runtime/structs.js'\nimport { parseSignature } from './runtime/utils.js'\nimport type { Signatures } from './types/signatures.js'\nimport type { ParseStructs } from './types/structs.js'\nimport type { ParseSignature } from './types/utils.js'\n\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * type Result = ParseAbi<\n *   // ^? type Result = readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   [\n *     'function balanceOf(address owner) view returns (uint256)',\n *     'event Transfer(address indexed from, address indexed to, uint256 amount)',\n *   ]\n * >\n */\nexport type ParseAbi<signatures extends readonly string[]> =\n  string[] extends signatures\n    ? Abi // If `T` was not able to be inferred (e.g. just `string[]`), return `Abi`\n    : signatures extends readonly string[]\n      ? signatures extends Signatures<signatures> // Validate signatures\n        ? ParseStructs<signatures> extends infer sructs\n          ? {\n              [key in keyof signatures]: signatures[key] extends string\n                ? ParseSignature<signatures[key], sructs>\n                : never\n            } extends infer mapped extends readonly unknown[]\n            ? Filter<mapped, never> extends infer result\n              ? result extends readonly []\n                ? never\n                : result\n              : never\n            : never\n          : never\n        : never\n      : never\n\n/**\n * Parses human-readable ABI into JSON {@link Abi}\n *\n * @param signatures - Human-Readable ABI\n * @returns Parsed {@link Abi}\n *\n * @example\n * const abi = parseAbi([\n *   //  ^? const abi: readonly [{ name: \"balanceOf\"; type: \"function\"; stateMutability:...\n *   'function balanceOf(address owner) view returns (uint256)',\n *   'event Transfer(address indexed from, address indexed to, uint256 amount)',\n * ])\n */\nexport function parseAbi<const signatures extends readonly string[]>(\n  signatures: signatures['length'] extends 0\n    ? Error<'At least one signature required'>\n    : Signatures<signatures> extends signatures\n      ? signatures\n      : Signatures<signatures>,\n): ParseAbi<signatures> {\n  const structs = parseStructs(signatures as readonly string[])\n  const abi = []\n  const length = signatures.length as number\n  for (let i = 0; i < length; i++) {\n    const signature = (signatures as readonly string[])[i]!\n    if (isStructSignature(signature)) continue\n    abi.push(parseSignature(signature, structs))\n  }\n  return abi as unknown as ParseAbi<signatures>\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_gasPrice } from \"../rpc/actions/eth_gasPrice.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\n\nexport type GetGasPriceOptions = {\n  client: ThirdwebClient;\n  chain: Chain;\n  percentMultiplier?: number;\n};\n\n/**\n * Retrieves the gas price for a transaction on a specific chain.\n * @param client - The Thirdweb client.\n * @param chain - The ID of the chain.\n * @returns A promise that resolves to the gas price as a bigint.\n * @example\n * ```ts\n * import { getGasPrice } from \"thirdweb\";\n *\n * const gasPrice = await getGasPrice({ client, chain });\n * ```\n * @utils\n */\nexport async function getGasPrice(\n  options: GetGasPriceOptions,\n): Promise<bigint> {\n  const { client, chain, percentMultiplier } = options;\n  const rpcClient = getRpcClient({ client, chain });\n  const gasPrice_ = await eth_gasPrice(rpcClient);\n  const extraTip = percentMultiplier\n    ? (gasPrice_ / BigInt(100)) * BigInt(percentMultiplier)\n    : 0n;\n  const txGasPrice = gasPrice_ + extraTip;\n  return txGasPrice;\n}\n", "/**\n * Resolves a possibly asynchronous value.\n * If the value is a function that returns a promise, it will be awaited and the resolved value will be returned.\n * Otherwise, the value itself will be returned.\n *\n * @param value - The value to resolve.\n * @returns A promise that resolves to the resolved value.\n * @internal\n */\nexport async function resolvePromisedValue<V>(\n  value: V,\n): Promise<V extends () => Promise<infer R> ? R : V> {\n  // @ts-expect-error - this works fine, but TS doesn't like it since 5.8\n  return typeof value === \"function\" ? await value() : value;\n}\n\ntype PromisedValue<T> = T | (() => Promise<T>);\n\nexport type PromisedObject<T> = {\n  [K in keyof T]: PromisedValue<T[K]>;\n};\n", "/**\n * Via: https://twitter.com/0xjustadev/status/1758973668011434062\n *\n * Increases the gas fee value to the nearest power of 2.\n * If the value is already a power of 2 or 0, it returns the value as is.\n * Otherwise, it finds the highest power of 2 that is bigger than the given value.\n * @param value - The gas fee value to be \"rounded up\".\n * @returns The *increased* gas value which will result in a lower L1 gas fee, overall reducing the gas fee.\n * @internal\n */\nexport function roundUpGas(value: bigint): bigint {\n  if (value === 0n || (value & (value - 1n)) === 0n) {\n    return value;\n  }\n\n  // Find the highest set bit by shifting until the value is 0.\n  let highestBit = 1n;\n  while (value > 0n) {\n    // biome-ignore lint/style/noParameterAssign: the whole point is that we modify the value in palce\n    value >>= 1n;\n    highestBit <<= 1n;\n  }\n\n  return highestBit;\n}\n", "import { type Abi, formatAbi, parseAbi } from \"abitype\";\nimport { download } from \"../../storage/download.js\";\nimport { getClientFetch } from \"../../utils/fetch.js\";\nimport { withCache } from \"../../utils/promise/withCache.js\";\nimport { type ThirdwebContract, getContract } from \"../contract.js\";\n\n/**\n * Resolves the ABI (Application Binary Interface) for a given contract.\n * If the ABI is already cached, it returns the cached value.\n * Otherwise, it tries to resolve the ABI from the contract's API.\n * If that fails, it resolves the ABI from the contract's bytecode.\n * @param contract The contract for which to resolve the ABI.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveContractAbi } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveContractAbi(myContract);\n * ```\n * @contract\n */\nexport function resolveContractAbi<abi extends Abi>(\n  contract: ThirdwebContract<abi>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<abi> {\n  return withCache(\n    async () => {\n      // if the contract already HAS a user defined we always use that!\n      if (contract.abi) {\n        return contract.abi as abi;\n      }\n\n      // for local chains, we need to resolve the composite abi from bytecode\n      if (contract.chain.id === 31337 || contract.chain.id === 1337) {\n        return (await resolveCompositeAbi(contract as ThirdwebContract)) as abi;\n      }\n\n      // try to get it from the api\n      try {\n        return (await resolveAbiFromContractApi(\n          contract,\n          contractApiBaseUrl,\n        )) as abi;\n      } catch {\n        // if that fails, try to resolve it from the bytecode\n        return (await resolveCompositeAbi(contract as ThirdwebContract)) as abi;\n      }\n    },\n    {\n      cacheKey: `${contract.chain.id}-${contract.address}`,\n      cacheTime: 1000 * 60 * 60 * 1, // 1 hour\n    },\n  );\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) for a contract from the contract API.\n * @param contract The ThirdwebContract instance representing the contract.\n * @param contractApiBaseUrl The base URL of the contract API. Defaults to \"https://contract.thirdweb.com/abi\".\n * @returns A promise that resolves to the ABI of the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromContractApi } from \"thirdweb/contract\"\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromContractApi(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromContractApi(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n  contractApiBaseUrl = \"https://contract.thirdweb.com/abi\",\n): Promise<Abi> {\n  const response = await getClientFetch(contract.client)(\n    `${contractApiBaseUrl}/${contract.chain.id}/${contract.address}`,\n  );\n  const json = await response.json();\n  if (!json || json.error) {\n    throw new Error(\n      `Failed to resolve ABI from contract API. ${json.error || \"\"}`,\n    );\n  }\n  return json;\n}\n\n/**\n * Resolves the ABI (Application Binary Interface) from the bytecode of a contract.\n * @param contract The ThirdwebContract instance.\n * @returns The resolved ABI as a generic type.\n * @throws Error if no IPFS URI is found in the bytecode.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveAbiFromBytecode(\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>,\n): Promise<Abi> {\n  const [{ resolveImplementation }, { extractIPFSUri }] = await Promise.all([\n    import(\"../../utils/bytecode/resolveImplementation.js\"),\n    import(\"../../utils/bytecode/extractIPFS.js\"),\n  ]);\n  const { bytecode } = await resolveImplementation(contract);\n  if (bytecode === \"0x\") {\n    const { id, name } = contract.chain;\n    throw new Error(\n      `Failed to load contract bytecode. Make sure the contract [${\n        contract.address\n      }] exists on the chain [${name || \"Unknown Chain\"} (chain id: ${id})]`,\n    );\n  }\n  const ipfsUri = extractIPFSUri(bytecode);\n  if (!ipfsUri) {\n    // just early exit if we can't find an IPFS URI\n    return [];\n  }\n  try {\n    const res = await download({ uri: ipfsUri, client: contract.client });\n    const json = await res.json();\n    // ABI is at `json.output.abi`\n    return json.output.abi;\n  } catch {\n    // if we can't resolve the ABI from the IPFS URI, return an empty array\n    return [];\n  }\n}\n\nconst PLUGINS_ABI = {\n  inputs: [],\n  name: \"getAllPlugins\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"bytes4\",\n          name: \"functionSelector\",\n          type: \"bytes4\",\n        },\n        {\n          internalType: \"string\",\n          name: \"functionSignature\",\n          type: \"string\",\n        },\n        {\n          internalType: \"address\",\n          name: \"pluginAddress\",\n          type: \"address\",\n        },\n      ],\n      internalType: \"struct IPluginMap.Plugin[]\",\n      name: \"registered\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst BASE_ROUTER_ABI = {\n  inputs: [],\n  name: \"getAllExtensions\",\n  outputs: [\n    {\n      components: [\n        {\n          components: [\n            {\n              internalType: \"string\",\n              name: \"name\",\n              type: \"string\",\n            },\n            {\n              internalType: \"string\",\n              name: \"metadataURI\",\n              type: \"string\",\n            },\n            {\n              internalType: \"address\",\n              name: \"implementation\",\n              type: \"address\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionMetadata\",\n          name: \"metadata\",\n          type: \"tuple\",\n        },\n        {\n          components: [\n            {\n              internalType: \"bytes4\",\n              name: \"functionSelector\",\n              type: \"bytes4\",\n            },\n            {\n              internalType: \"string\",\n              name: \"functionSignature\",\n              type: \"string\",\n            },\n          ],\n          internalType: \"struct IExtension.ExtensionFunction[]\",\n          name: \"functions\",\n          type: \"tuple[]\",\n        },\n      ],\n      internalType: \"struct IExtension.Extension[]\",\n      name: \"allExtensions\",\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\nconst DIAMOND_ABI = {\n  inputs: [],\n  name: \"facets\",\n  outputs: [\n    {\n      components: [\n        {\n          internalType: \"address\",\n          name: \"facetAddress\",\n          type: \"address\",\n        },\n        {\n          internalType: \"bytes4[]\",\n          name: \"functionSelectors\",\n          type: \"bytes4[]\",\n        },\n      ],\n      type: \"tuple[]\",\n    },\n  ],\n  stateMutability: \"view\",\n  type: \"function\",\n} as const;\n\n/**\n * Resolves the ABI for a contract based on its bytecode.\n * If the contract follows the plugin-pattern or dynamic pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the base router pattern, it resolves the ABIs for the plugins and merges them with the root ABI.\n * If the contract follows the diamond pattern, it resolves the ABIs for the facets and merges them with the root ABI.\n * @param contract The contract for which to resolve the ABI.\n * @param rootAbi The root ABI to use for the contract. If not provided, it resolves the ABI from the contract's bytecode.\n * @param resolveSubAbi A function to resolve the ABI for a sub-contract. If not provided, it uses the default ABI resolution logic.\n * @returns The resolved ABI for the contract.\n * @example\n * ```ts\n * import { createThirdwebClient, getContract } from \"thirdweb\";\n * import { resolveCompositeAbiFromBytecode } from \"thirdweb/contract\";\n * import { ethereum } from \"thirdweb/chains\";\n * const client = createThirdwebClient({ clientId: \"...\" });\n * const myContract = getContract({\n *  client,\n *  address: \"...\",\n *  chain: ethereum,\n * });\n * const abi = await resolveCompositeAbiFromBytecode(myContract);\n * ```\n * @contract\n */\nexport async function resolveCompositeAbi(\n  contract: ThirdwebContract,\n  rootAbi?: Abi,\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>,\n) {\n  const [\n    rootAbi_,\n    pluginPatternAddresses,\n    baseRouterAddresses,\n    modularExtensionAddresses,\n    diamondFacetAddresses,\n  ] = await Promise.all([\n    rootAbi ? rootAbi : resolveAbiFromBytecode(contract),\n    // check these all at the same time\n    resolvePluginPatternAddresses(contract),\n    resolveBaseRouterAddresses(contract),\n    resolveModularModuleAddresses(contract),\n    resolveDiamondFacetAddresses(contract),\n  ]);\n\n  const mergedPlugins = [\n    ...new Set([\n      ...pluginPatternAddresses,\n      ...baseRouterAddresses,\n      ...modularExtensionAddresses,\n      ...diamondFacetAddresses,\n    ]),\n  ];\n\n  // no plugins\n  if (!mergedPlugins.length) {\n    return rootAbi_;\n  }\n  // get all the abis for the plugins\n  const pluginAbis = await getAbisForPlugins({\n    contract,\n    plugins: mergedPlugins,\n    resolveSubAbi,\n  });\n\n  // join them together\n  return joinAbis({ rootAbi: rootAbi_, pluginAbis });\n}\n\nasync function resolvePluginPatternAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: PLUGINS_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.pluginAddress))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveBaseRouterAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const pluginMap = await readContract({\n      contract,\n      method: BASE_ROUTER_ABI,\n    });\n    // if there are no plugins, return the root ABI\n    if (!pluginMap.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(pluginMap.map((item) => item.metadata.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveModularModuleAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { getInstalledModules } = await import(\n      \"../../extensions/modules/__generated__/IModularCore/read/getInstalledModules.js\"\n    );\n    const modules = await getInstalledModules({ contract });\n    // if there are no plugins, return the root ABI\n    if (!modules.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return [...new Set(modules.map((item) => item.implementation))];\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\nasync function resolveDiamondFacetAddresses(\n  contract: ThirdwebContract,\n): Promise<string[]> {\n  try {\n    const { readContract } = await import(\"../../transaction/read-contract.js\");\n    const facets = await readContract({ contract, method: DIAMOND_ABI });\n    // if there are no facets, return the root ABI\n    if (!facets.length) {\n      return [];\n    }\n    // get all the plugin addresses\n    return facets.map((item) => item.facetAddress);\n  } catch {\n    // no-op, expected because not everything supports this\n  }\n  return [];\n}\n\ntype GetAbisForPluginsOptions = {\n  // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any contract type\n  contract: ThirdwebContract<any>;\n  plugins: string[];\n  resolveSubAbi?: (contract: ThirdwebContract) => Promise<Abi>;\n};\n\nasync function getAbisForPlugins(\n  options: GetAbisForPluginsOptions,\n): Promise<Abi[]> {\n  return Promise.all(\n    options.plugins.map((pluginAddress) => {\n      const newContract = getContract({\n        ...options.contract,\n        address: pluginAddress,\n      });\n      // if we have a method passed in that tells us how to resove the sub-api, use that\n      if (options.resolveSubAbi) {\n        return options.resolveSubAbi(newContract);\n      }\n      // otherwise default logic\n      return resolveAbiFromBytecode(newContract);\n    }),\n  );\n}\n\ntype JoinAbisOptions = {\n  pluginAbis: Abi[];\n  rootAbi?: Abi;\n};\n\nfunction joinAbis(options: JoinAbisOptions): Abi {\n  let mergedPlugins: Abi = options.pluginAbis\n    .flat()\n    .filter((item) => item.type !== \"constructor\");\n\n  if (options.rootAbi) {\n    mergedPlugins = [...options.rootAbi, ...mergedPlugins]\n      .filter((item) => item.type !== \"fallback\" && item.type !== \"receive\")\n      .filter(Boolean);\n  }\n\n  // unique by formatting every abi and then throwing them in a set\n  // TODO: this may not be super efficient...\n  const humanReadableAbi = [...new Set(formatAbi(mergedPlugins))];\n\n  // finally parse it back out\n  return parseAbi(humanReadableAbi);\n}\n", "import type { Abi } from \"abitype\";\nimport { type Hex, decodeErrorResult, stringify } from \"viem\";\nimport { resolveContractAbi } from \"../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../contract/contract.js\";\nimport { isHex } from \"../utils/encoding/hex.js\";\nimport { IS_DEV } from \"../utils/process.js\";\n\n/**\n * @internal\n */\nexport async function extractError<abi extends Abi>(args: {\n  error: unknown;\n  contract?: ThirdwebContract<abi>;\n}) {\n  const { error, contract } = args;\n  const result = await extractErrorResult({ error, contract });\n  if (result) {\n    return new TransactionError(result, contract);\n  }\n  return error;\n}\n\nexport async function extractErrorResult<abi extends Abi>(args: {\n  error: unknown;\n  contract?: ThirdwebContract<abi>;\n}): Promise<string | undefined> {\n  const { error, contract } = args;\n  if (typeof error === \"object\") {\n    // try to parse RPC error\n    const errorObj = error as {\n      message?: string;\n      code?: number;\n      data?: Hex;\n    };\n    if (errorObj.data) {\n      if (errorObj.data !== \"0x\" && isHex(errorObj.data)) {\n        let abi = contract?.abi;\n        if (contract && !abi) {\n          abi = await resolveContractAbi(contract).catch(() => undefined);\n        }\n        const parsedError = decodeErrorResult({\n          data: errorObj.data,\n          abi,\n        });\n        return `${parsedError.errorName}${parsedError.args ? ` - ${parsedError.args}` : \"\"}`;\n      }\n    }\n  }\n  return `Execution Reverted: ${stringify(error)}`;\n}\n\nclass TransactionError<abi extends Abi> extends Error {\n  public contractAddress: string | undefined;\n  public chainId: number | undefined;\n\n  constructor(reason: string, contract?: ThirdwebContract<abi>) {\n    let message = reason;\n    if (IS_DEV && contract) {\n      // show more infor in dev\n      message = [\n        reason,\n        \"\",\n        `contract: ${contract.address}`,\n        `chainId: ${contract.chain?.id}`,\n      ].join(\"\\n\");\n    }\n    super(message);\n    this.name = \"TransactionError\";\n    this.contractAddress = contract?.address;\n    this.chainId = contract?.chain?.id;\n    this.message = message;\n  }\n}\n", "import * as ox__Hex from \"ox/Hex\";\nimport { formatTransactionRequest } from \"viem\";\nimport { roundUpGas } from \"../../gas/op-gas-fee-reducer.js\";\nimport { getAddress } from \"../../utils/address.js\";\nimport { resolvePromisedValue } from \"../../utils/promise/resolve-promised-value.js\";\nimport type { Prettify } from \"../../utils/type-utils.js\";\nimport type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { extractError } from \"../extract-error.js\";\nimport type { PreparedTransaction } from \"../prepare-transaction.js\";\n\nexport type EstimateGasOptions = Prettify<\n  {\n    /**\n     * The prepared transaction to estimate the gas for.\n     */\n    // TODO: update this to `Transaction<\"prepared\">` once the type is available to ensure only prepared transactions are accepted\n    // biome-ignore lint/suspicious/noExplicitAny: library function that accepts any prepared transaction type\n    transaction: PreparedTransaction<any>;\n  } & (\n    | {\n        /**\n         * The account the transaction would be sent from.\n         *\n         * @deprecated Use `from` instead\n         */\n        account: Account;\n        from?: never;\n      }\n    | {\n        account?: never;\n        /**\n         * The address the transaction would be sent from.\n         */\n        from?: string | Account;\n      }\n  )\n>;\n\nexport type EstimateGasResult = bigint;\n\nconst cache = new WeakMap<\n  PreparedTransaction & { from: string | undefined },\n  Promise<EstimateGasResult>\n>();\n\n/**\n * Estimates the gas required to execute a transaction. The gas is returned as a `bigint` and in gwei units.\n * @param options - The options for estimating gas.\n * @returns A promise that resolves to the estimated gas as a bigint.\n * @transaction\n * @example\n * ```ts\n * import { estimateGas } from \"thirdweb\";\n * const gas = await estimateGas({\n *  transaction,\n *  from: \"0x...\",\n * });\n * ```\n */\nexport async function estimateGas(\n  options: EstimateGasOptions,\n): Promise<EstimateGasResult> {\n  // from is:\n  // 1. the user specified from address\n  // 2. the passed in account address\n  // 3. the passed in wallet's account address\n  const fromAddress =\n    typeof options.from === \"string\"\n      ? (options.from ?? undefined)\n      : (options.from?.address ?? options.account?.address);\n  const txWithFrom = { ...options.transaction, from: fromAddress };\n  if (cache.has(txWithFrom)) {\n    // biome-ignore lint/style/noNonNullAssertion: the `has` above ensures that this will always be set\n    return cache.get(txWithFrom)!;\n  }\n  const { account } = options;\n  const promise = (async () => {\n    const predefinedGas = await resolvePromisedValue(options.transaction.gas);\n    // if we have a predefined gas value in the TX -> always use that\n    if (predefinedGas !== undefined) {\n      return predefinedGas;\n    }\n\n    // if the wallet itself overrides the estimateGas function, use that\n    if (account?.estimateGas) {\n      try {\n        let gas = await account.estimateGas(options.transaction);\n        if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n          gas = roundUpGas(gas);\n        }\n        return gas;\n      } catch (error) {\n        throw await extractError({\n          error,\n          contract: options.transaction.__contract,\n        });\n      }\n    }\n\n    // load up encode function if we need it\n    const { encode } = await import(\"./encode.js\");\n    const [encodedData, toAddress, value, authorizationList] =\n      await Promise.all([\n        encode(options.transaction),\n        resolvePromisedValue(options.transaction.to),\n        resolvePromisedValue(options.transaction.value),\n        resolvePromisedValue(options.transaction.authorizationList),\n      ]);\n\n    // load up the rpc client and the estimateGas function if we need it\n    const [{ getRpcClient }, { eth_estimateGas }] = await Promise.all([\n      import(\"../../rpc/rpc.js\"),\n      import(\"../../rpc/actions/eth_estimateGas.js\"),\n    ]);\n\n    const rpcRequest = getRpcClient(options.transaction);\n    try {\n      let gas = await eth_estimateGas(\n        rpcRequest,\n        formatTransactionRequest({\n          to: toAddress ? getAddress(toAddress) : undefined,\n          data: encodedData,\n          from: fromAddress ? getAddress(fromAddress) : undefined,\n          value,\n          // TODO: Remove this casting when we migrate this file to Ox\n          authorizationList: authorizationList?.map((auth) => ({\n            ...auth,\n            r: ox__Hex.fromNumber(auth.r),\n            s: ox__Hex.fromNumber(auth.s),\n            nonce: Number(auth.nonce),\n            contractAddress: getAddress(auth.address),\n          })),\n        }),\n      );\n\n      if (options.transaction.chain.experimental?.increaseZeroByteCount) {\n        gas = roundUpGas(gas);\n      }\n      return gas;\n    } catch (error) {\n      throw await extractError({\n        error,\n        contract: options.transaction.__contract,\n      });\n    }\n  })();\n  cache.set(txWithFrom, promise);\n  return promise;\n}\n", "import type { Chain } from \"../chains/types.js\";\nimport type { ThirdwebClient } from \"../client/client.js\";\nimport { eth_getBlockByNumber } from \"../rpc/actions/eth_getBlockByNumber.js\";\nimport { eth_maxPriorityFeePerGas } from \"../rpc/actions/eth_maxPriorityFeePerGas.js\";\nimport { getRpcClient } from \"../rpc/rpc.js\";\nimport type { PreparedTransaction } from \"../transaction/prepare-transaction.js\";\nimport { resolvePromisedValue } from \"../utils/promise/resolve-promised-value.js\";\nimport { toUnits } from \"../utils/units.js\";\nimport { getGasPrice } from \"./get-gas-price.js\";\nimport { roundUpGas } from \"./op-gas-fee-reducer.js\";\n\ntype FeeData = {\n  maxFeePerGas: null | bigint;\n  maxPriorityFeePerGas: null | bigint;\n};\n\ntype FeeDataParams =\n  | {\n      gasPrice?: never;\n      maxFeePerGas?: bigint;\n      maxPriorityFeePerGas?: bigint;\n    }\n  | {\n      gasPrice?: bigint;\n      maxFeePerGas?: never;\n      maxPriorityFeePerGas?: never;\n    };\n\n// for these chains - always force pre eip1559 transactions\nconst FORCE_GAS_PRICE_CHAIN_IDS = [\n  78600, // Vanar testnet\n  2040, // Vanar mainnet\n  248, // Oasys Mainnet\n  9372, // Oasys Testnet\n  841, // Taraxa Mainnet\n  842, // Taraxa Testnet\n  2016, // MainnetZ Mainnet\n  9768, // MainnetZ Testnet\n  2442, // Polygon zkEVM Cardona Testnet\n  1942999413, // Humanity Testnet\n  1952959480, // Lumia Testnet\n  994873017, // Lumia Mainnet\n  19011, // Homeverse Mainnet\n  40875, // Homeverse Testnet\n  1511670449, // GPT Mainnet\n  5464, // Saga Mainnet\n  2020, // Ronin Mainnet\n  2021, // Ronin Testnet (Saigon)\n];\n\n/**\n *\n * @internal\n */\nexport async function getGasOverridesForTransaction(\n  transaction: PreparedTransaction,\n): Promise<FeeDataParams> {\n  // first check for explicit values\n  const [maxFeePerGas, maxPriorityFeePerGas, gasPrice, type] =\n    await Promise.all([\n      resolvePromisedValue(transaction.maxFeePerGas),\n      resolvePromisedValue(transaction.maxPriorityFeePerGas),\n      resolvePromisedValue(transaction.gasPrice),\n      resolvePromisedValue(transaction.type),\n    ]);\n\n  // Exit early if the user explicitly provided enough options\n  if (maxFeePerGas !== undefined && maxPriorityFeePerGas !== undefined) {\n    return {\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n    };\n  }\n\n  if (typeof gasPrice === \"bigint\") {\n    return { gasPrice };\n  }\n\n  // If we don't have enough explicit values, get defaults\n  const defaultGasOverrides = await getDefaultGasOverrides(\n    transaction.client,\n    transaction.chain,\n    type === \"legacy\" ? \"legacy\" : \"eip1559\", // 7702, 2930, and eip1559 all qualify as \"eip1559\" fee type\n  );\n\n  if (transaction.chain.experimental?.increaseZeroByteCount) {\n    // otherwise adjust each value\n    if (defaultGasOverrides.gasPrice) {\n      return { gasPrice: roundUpGas(defaultGasOverrides.gasPrice) };\n    }\n\n    return {\n      maxFeePerGas:\n        maxFeePerGas ?? roundUpGas(defaultGasOverrides.maxFeePerGas ?? 0n),\n      maxPriorityFeePerGas:\n        maxPriorityFeePerGas ??\n        roundUpGas(defaultGasOverrides.maxPriorityFeePerGas ?? 0n),\n    };\n  }\n\n  // return as is\n  if (defaultGasOverrides.gasPrice !== undefined) {\n    return defaultGasOverrides;\n  }\n\n  // Still check for explicit values in case one is provided and not the other\n  return {\n    maxFeePerGas: maxFeePerGas ?? defaultGasOverrides.maxFeePerGas,\n    maxPriorityFeePerGas:\n      maxPriorityFeePerGas ?? defaultGasOverrides.maxPriorityFeePerGas,\n  };\n}\n\nexport type FeeType = \"legacy\" | \"eip1559\";\n\n/**\n * Retrieves the default gas overrides for a given client and chain ID.\n * If the fee data contains both maxFeePerGas and maxPriorityFeePerGas, it returns an object with those values.\n * Otherwise, it returns an object with the gasPrice obtained from the client and chain ID.\n * @param client - The ThirdwebClient instance.\n * @param chain - The chain ID.\n * @returns An object containing the default gas overrides.\n * @internal\n */\nexport async function getDefaultGasOverrides(\n  client: ThirdwebClient,\n  chain: Chain,\n  feeType?: FeeType,\n) {\n  // give priority to the transaction fee type over the chain fee type\n  const resolvedFeeType = feeType ?? chain.feeType;\n  // if chain is configured to force legacy transactions or is in the legacy chain list\n  if (\n    resolvedFeeType === \"legacy\" ||\n    FORCE_GAS_PRICE_CHAIN_IDS.includes(chain.id)\n  ) {\n    return {\n      gasPrice: await getGasPrice({ client, chain, percentMultiplier: 10 }),\n    };\n  }\n  const feeData = await getDynamicFeeData(client, chain);\n  if (feeData.maxFeePerGas !== null && feeData.maxPriorityFeePerGas !== null) {\n    return {\n      maxFeePerGas: feeData.maxFeePerGas,\n      maxPriorityFeePerGas: feeData.maxPriorityFeePerGas,\n    };\n  }\n  // TODO: resolvedFeeType here could be \"EIP1559\", but we could not get EIP1559 fee data. should we throw?\n  return {\n    gasPrice: await getGasPrice({ client, chain, percentMultiplier: 10 }),\n  };\n}\n\n/**\n * Retrieves dynamic fee data for a given chain.\n * @param client - The Thirdweb client.\n * @param chain - The chain ID.\n * @returns A promise that resolves to the fee data.\n * @internal\n */\nasync function getDynamicFeeData(\n  client: ThirdwebClient,\n  chain: Chain,\n  percentMultiplier = 10,\n): Promise<FeeData> {\n  let maxFeePerGas: null | bigint = null;\n  let maxPriorityFeePerGas_: null | bigint = null;\n\n  const rpcRequest = getRpcClient({ client, chain });\n\n  const [block, maxPriorityFeePerGas] = await Promise.all([\n    eth_getBlockByNumber(rpcRequest, { blockTag: \"latest\" }),\n    eth_maxPriorityFeePerGas(rpcRequest).catch(() => null),\n  ]);\n\n  const baseBlockFee = block?.baseFeePerGas;\n\n  const chainId = chain.id;\n  // flag chain testnet & flag chain\n  if (chainId === 220 || chainId === 1220) {\n    // these does not support eip-1559, for some reason even though `eth_maxPriorityFeePerGas` is available?!?\n    // return null because otherwise TX break\n    return { maxFeePerGas: null, maxPriorityFeePerGas: null };\n    // mumbai & polygon\n  }\n  if (chainId === 80002 || chainId === 137) {\n    // for polygon, get fee data from gas station\n    maxPriorityFeePerGas_ = await getPolygonGasPriorityFee(chainId);\n  } else if (maxPriorityFeePerGas !== null) {\n    // prioritize fee from eth_maxPriorityFeePerGas\n    maxPriorityFeePerGas_ = maxPriorityFeePerGas;\n  }\n\n  if (maxPriorityFeePerGas_ == null || baseBlockFee == null) {\n    // chain does not support eip-1559, return null for both\n    return { maxFeePerGas: null, maxPriorityFeePerGas: null };\n  }\n\n  // add 10% tip to maxPriorityFeePerGas for faster processing\n  maxPriorityFeePerGas_ = getPreferredPriorityFee(\n    maxPriorityFeePerGas_,\n    percentMultiplier,\n  );\n  // eip-1559 formula, doubling the base fee ensures that the tx can be included in the next 6 blocks no matter how busy the network is\n  // good article on the subject: https://www.blocknative.com/blog/eip-1559-fees\n  maxFeePerGas = baseBlockFee * 2n + maxPriorityFeePerGas_;\n\n  // special cased for Celo gas fees\n  if (chainId === 42220 || chainId === 44787 || chainId === 62320) {\n    maxPriorityFeePerGas_ = maxFeePerGas;\n  }\n\n  return {\n    maxFeePerGas,\n    maxPriorityFeePerGas: maxPriorityFeePerGas_,\n  };\n}\n\n/**\n * Calculates the preferred priority fee based on the default priority fee per gas and a percent multiplier.\n * @param defaultPriorityFeePerGas - The default priority fee per gas.\n * @param percentMultiplier - The percent multiplier to calculate the extra tip. Default is 10.\n * @returns The total priority fee including the extra tip.\n * @internal\n */\nfunction getPreferredPriorityFee(\n  defaultPriorityFeePerGas: bigint,\n  percentMultiplier = 10,\n): bigint {\n  const extraTip =\n    (defaultPriorityFeePerGas / BigInt(100)) * BigInt(percentMultiplier);\n  const totalPriorityFee = defaultPriorityFeePerGas + extraTip;\n  return totalPriorityFee;\n}\n\n/**\n * @internal\n */\nfunction getGasStationUrl(chainId: 137 | 80002): string {\n  switch (chainId) {\n    case 137:\n      return \"https://gasstation.polygon.technology/v2\";\n    case 80002:\n      return \"https://gasstation-testnet.polygon.technology/v2\";\n  }\n}\n\nconst MIN_POLYGON_GAS_PRICE = 31n; // 31 gwei\n\n/**\n *\n * @returns The gas price\n * @internal\n */\nasync function getPolygonGasPriorityFee(chainId: 137 | 80002): Promise<bigint> {\n  const gasStationUrl = getGasStationUrl(chainId);\n  try {\n    const data = await (await fetch(gasStationUrl)).json();\n    // take the standard speed here, SDK options will define the extra tip\n    const priorityFee = data.fast.maxPriorityFee;\n    if (priorityFee > 0) {\n      const fixedFee = Number.parseFloat(priorityFee).toFixed(9);\n      return toUnits(fixedFee, 9);\n    }\n  } catch (e) {\n    console.error(\"failed to fetch gas\", e);\n  }\n  return MIN_POLYGON_GAS_PRICE;\n}\n"],
  "mappings": "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",
  "names": ["_a", "_b", "getRpcClient"]
}
