import {
  sign
} from "./chunk-2JMEOC4X.js";
import {
  toHex
} from "./chunk-5DLV5WR6.js";
import {
  getSignPayload
} from "./chunk-RLZQZOTA.js";
import {
  keccak256
} from "./chunk-CQABUGWC.js";
import {
  concat,
  from,
  fromString,
  size,
  toNumber
} from "./chunk-I364SXDL.js";

// node_modules/ox/_esm/core/PersonalMessage.js
function encode(data) {
  const message = from(data);
  return concat(
    // Personal Sign Format: `0x19 ‖ "Ethereum Signed Message:\n" ‖ message.length ‖ message`
    "0x19",
    fromString("Ethereum Signed Message:\n" + size(message)),
    message
  );
}
function getSignPayload2(data) {
  return keccak256(encode(data));
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-message.js
function signMessage(options) {
  if ("privateKey" in options) {
    const payload = getSignPayload2(typeof options.message === "object" ? options.message.raw : fromString(options.message));
    const signature = sign({
      payload,
      privateKey: options.privateKey
    });
    return toHex(signature);
  }
  if ("account" in options) {
    const { message, account } = options;
    return account.signMessage({ message });
  }
  throw new Error("Either privateKey or account is required");
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign-typed-data.js
function signTypedData(options) {
  var _a;
  const { privateKey, ...typedData } = options;
  if (typeof ((_a = typedData.domain) == null ? void 0 : _a.chainId) === "string") {
    typedData.domain.chainId = toNumber(typedData.domain.chainId);
  }
  const payload = getSignPayload(typedData);
  const signature = sign({
    payload,
    privateKey
  });
  return toHex(signature);
}

export {
  signMessage,
  signTypedData
};
//# sourceMappingURL=chunk-ZSBKCZVH.js.map
