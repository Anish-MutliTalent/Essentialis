{
  "version": 3,
  "sources": ["../../ox/core/ContractAddress.ts", "../../thirdweb/src/utils/any-evm/is-eip155-enforced.ts", "../../thirdweb/src/utils/any-evm/keyless-transaction.ts", "../../thirdweb/src/contract/deployment/utils/create-2-factory.ts", "../../thirdweb/src/utils/any-evm/keccak-id.ts", "../../thirdweb/src/utils/any-evm/get-salt-hash.ts", "../../thirdweb/src/utils/any-evm/compute-deployment-address.ts", "../../thirdweb/src/utils/any-evm/get-init-bytecode-with-salt.ts", "../../thirdweb/src/utils/signatures/resolve-signature.ts", "../../thirdweb/src/utils/signatures/sign.ts", "../../thirdweb/src/utils/signatures/signature-to-hex.ts", "../../ox/core/AbiError.ts", "../../thirdweb/src/utils/abi/decodeError.ts", "../../thirdweb/src/utils/abi/decodeFunctionData.ts", "../../thirdweb/src/utils/abi/decodeFunctionResult.ts", "../../thirdweb/src/utils/jwt/jwt-header.ts", "../../thirdweb/src/utils/jwt/decode-jwt.ts", "../../thirdweb/src/utils/jwt/encode-jwt.ts", "../../thirdweb/src/utils/jwt/refresh-jwt.ts", "../../thirdweb/src/utils/contract/parse-abi-params.ts"],
  "sourcesContent": ["import * as Address from './Address.js'\nimport * as Bytes from './Bytes.js'\nimport type * as Errors from './Errors.js'\nimport * as Hash from './Hash.js'\nimport * as Hex from './Hex.js'\nimport * as Rlp from './Rlp.js'\nimport type { OneOf } from './internal/types.js'\n\n/**\n * Computes Contract Address generated by the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) or [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ### CREATE\n *\n * Computes via the [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @example\n * ### CREATE2\n *\n * Computes via the [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode. Shorthand for {@link ox#ContractAddress.(fromCreate2:function)}.\n *\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n * ContractAddress.from({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options.\n * @returns Contract Address.\n */\nexport function from(options: from.Options): Address.Address {\n  if (options.salt) return fromCreate2(options)\n  return fromCreate(options)\n}\n\nexport declare namespace from {\n  export type Options = OneOf<fromCreate.Options | fromCreate2.Options>\n\n  type ErrorType =\n    | fromCreate.ErrorType\n    | fromCreate2.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes contract address via [CREATE](https://ethereum.stackexchange.com/questions/68943/create-opcode-what-does-it-really-do/68945#68945) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress } from 'ox'\n *\n * ContractAddress.fromCreate({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   nonce: 0n,\n * })\n * // @log: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nexport function fromCreate(options: fromCreate.Options): Address.Address {\n  const from = Bytes.fromHex(Address.from(options.from))\n\n  let nonce = Bytes.fromNumber(options.nonce)\n  if (nonce[0] === 0) nonce = new Uint8Array([])\n\n  return Address.from(\n    `0x${Hash.keccak256(Rlp.fromBytes([from, nonce], { as: 'Hex' })).slice(26)}` as Address.Address,\n  )\n}\n\nexport declare namespace fromCreate {\n  type Options = {\n    /** The address the contract was deployed from. */\n    from: Address.Address\n    /** The nonce of the transaction which deployed the contract. */\n    nonce: bigint\n  }\n\n  type ErrorType =\n    | Hash.keccak256.ErrorType\n    | Address.from.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Bytes.fromNumber.ErrorType\n    | Rlp.fromBytes.ErrorType\n    | Errors.GlobalErrorType\n}\n\n/**\n * Computes contract address via [CREATE2](https://eips.ethereum.org/EIPS/eip-1014) opcode.\n *\n * @example\n * ```ts twoslash\n * import { ContractAddress, Hex } from 'ox'\n *\n * ContractAddress.fromCreate2({\n *   from: '0x1a1e021a302c237453d3d45c7b82b19ceeb7e2e6',\n *   bytecode: '0x6394198df16000526103ff60206004601c335afa6040516060f3',\n *   salt: Hex.fromString('hello world'),\n * })\n * // @log: '0x59fbB593ABe27Cb193b6ee5C5DC7bbde312290aB'\n * ```\n *\n * @param options - Options for retrieving address.\n * @returns Contract Address.\n */\nexport function fromCreate2(options: fromCreate2.Options): Address.Address {\n  const from = Bytes.fromHex(Address.from(options.from))\n  const salt = Bytes.padLeft(\n    Bytes.validate(options.salt) ? options.salt : Bytes.fromHex(options.salt),\n    32,\n  )\n\n  const bytecodeHash = (() => {\n    if ('bytecodeHash' in options) {\n      if (Bytes.validate(options.bytecodeHash)) return options.bytecodeHash\n      return Bytes.fromHex(options.bytecodeHash)\n    }\n    return Hash.keccak256(options.bytecode, { as: 'Bytes' })\n  })()\n\n  return Address.from(\n    Hex.slice(\n      Hash.keccak256(\n        Bytes.concat(Bytes.fromHex('0xff'), from, salt, bytecodeHash),\n        { as: 'Hex' },\n      ),\n      12,\n    ),\n  )\n}\n\nexport declare namespace fromCreate2 {\n  type Options =\n    | {\n        bytecode: Bytes.Bytes | Hex.Hex\n        from: Address.Address\n        salt: Bytes.Bytes | Hex.Hex\n      }\n    | {\n        bytecodeHash: Bytes.Bytes | Hex.Hex\n        from: Address.Address\n        salt: Bytes.Bytes | Hex.Hex\n      }\n\n  type ErrorType =\n    | Address.from.ErrorType\n    | Bytes.concat.ErrorType\n    | Bytes.validate.ErrorType\n    | Bytes.padLeft.ErrorType\n    | Hash.keccak256.ErrorType\n    | Hex.slice.ErrorType\n    | Bytes.fromHex.ErrorType\n    | Errors.GlobalErrorType\n}\n", "import type { Chain } from \"../../chains/types.js\";\nimport type { ThirdwebClient } from \"../../client/client.js\";\nimport { eth_sendRawTransaction } from \"../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../rpc/rpc.js\";\n\n// it's OK to cache this forever because:\n// 1. the results can't change\n// 2. the total size can be max <number of chains> * boolean\nconst EIP_ENFORCED_CACHE = new Map<number, boolean>();\n\ntype IsEIP155EnforcedOptions = {\n  chain: Chain;\n  client: ThirdwebClient;\n};\n\n/**\n * Checks whether EIP-155 is enforced by sending a random transaction of legacy type (pre-EIP-155)\n * and parsing the error message.\n * @param options - The options for checking EIP-155 enforcement.\n * @returns A promise that resolves to a boolean indicating whether EIP-155 is enforced.\n * @example\n * ```ts\n * import { isEIP155Enforced } from \"thirdweb/utils\";\n * const isEIP155 = await isEIP155Enforced({ chain, client });\n * ```\n * @utils\n */\nexport async function isEIP155Enforced(\n  options: IsEIP155EnforcedOptions,\n): Promise<boolean> {\n  const chainId = options.chain.id;\n  // cache because the result cannot change\n  if (EIP_ENFORCED_CACHE.has(chainId)) {\n    return EIP_ENFORCED_CACHE.get(chainId) as boolean;\n  }\n  let result = false;\n  try {\n    // TODO: Find a better way to check this.\n\n    // Send a random transaction of legacy type (pre-eip-155).\n    // It will fail. Parse the error message to check whether eip-155 is enforced.\n    const rpcRequest = getRpcClient(options);\n    await eth_sendRawTransaction(\n      rpcRequest,\n      \"0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222\",\n    );\n    // biome-ignore lint/suspicious/noExplicitAny: TODO: fix later\n  } catch (e: any) {\n    const errorMsg = e.toString().toLowerCase();\n    const errorJson = JSON.stringify(e).toLowerCase();\n\n    if (matchError(errorMsg) || matchError(errorJson)) {\n      result = true;\n    }\n  }\n  EIP_ENFORCED_CACHE.set(chainId, result);\n  return result;\n}\n\nconst ERROR_SUBSTRINGS_COMPOSITE = [\n  [\"account\", \"not found\"],\n  [\"wrong\", \"chainid\"],\n];\nconst ERROR_SUBSTRINGS = [\n  \"eip-155\",\n  \"eip155\",\n  \"protected\",\n  \"invalid chain id for signer\",\n  \"chain id none\",\n  \"chain_id mismatch\",\n  \"recovered sender mismatch\",\n  \"transaction hash mismatch\",\n  \"chainid no support\",\n  \"chainid (0)\",\n  \"chainid(0)\",\n  \"invalid sender\",\n];\n\nfunction matchError(error: string): boolean {\n  const hasError = ERROR_SUBSTRINGS.some((substring) =>\n    error.includes(substring),\n  );\n  // can early exit if we find a match\n  if (hasError) {\n    return true;\n  }\n\n  // otherwise return true if any of the composite substrings are found\n  return ERROR_SUBSTRINGS_COMPOSITE.some((arr) => {\n    let foundError = true;\n\n    for (const substring of arr) {\n      foundError &&= error.includes(substring);\n    }\n    return foundError;\n  });\n}\n", "import * as ox__Hash from \"ox/Hash\";\nimport * as ox__Hex from \"ox/Hex\";\nimport * as ox__Signature from \"ox/Signature\";\nimport { recoverAddress } from \"viem\";\nimport {\n  type SerializableTransaction,\n  serializeTransaction,\n} from \"../../transaction/serialize-transaction.js\";\nimport type { Hex } from \"../encoding/hex.js\";\n\ntype GetKeylessTransactionOptions = {\n  transaction: SerializableTransaction;\n  signature:\n    | ox__Signature.Signature<true, Hex>\n    | ox__Signature.Legacy<Hex, bigint>;\n};\n\n/**\n * Retrieves the keyless transaction information.\n *\n * @param options - The options for retrieving the keyless transaction.\n * @returns An object containing the signer address and the signed serialized transaction string.\n * @internal\n */\nexport async function getKeylessTransaction(\n  options: GetKeylessTransactionOptions,\n) {\n  // 1. Create serialized txn string\n  const hash = ox__Hash.keccak256(\n    serializeTransaction({ transaction: options.transaction }),\n  );\n\n  const yParity = (() => {\n    if (\n      \"yParity\" in options.signature &&\n      typeof options.signature.yParity !== \"undefined\"\n    ) {\n      return options.signature.yParity;\n    }\n\n    if (\n      \"v\" in options.signature &&\n      typeof options.signature.v !== \"undefined\"\n    ) {\n      return ox__Signature.vToYParity(Number(options.signature.v));\n    }\n\n    throw new Error(\n      \"Invalid recovered signature provided with transaction, missing v or yParity\",\n    );\n  })();\n\n  // 2. Determine signer address from custom signature + txn\n  const address = await recoverAddress({\n    hash,\n    signature: ox__Signature.toHex({\n      r: ox__Hex.toBigInt(options.signature.r),\n      s: ox__Hex.toBigInt(options.signature.s),\n      yParity,\n    }),\n  });\n\n  // 3. Create the signed serialized txn string.\n  // To be sent directly to the chain using a provider.\n  const transaction = serializeTransaction({\n    transaction: options.transaction,\n    signature: options.signature,\n  });\n\n  return {\n    signerAddress: address,\n    transaction,\n  };\n}\n", "import * as ox__ContractAddress from \"ox/ContractAddress\";\nimport { getGasPrice } from \"../../../gas/get-gas-price.js\";\nimport { eth_getBalance } from \"../../../rpc/actions/eth_getBalance.js\";\nimport { eth_sendRawTransaction } from \"../../../rpc/actions/eth_sendRawTransaction.js\";\nimport { getRpcClient } from \"../../../rpc/rpc.js\";\nimport { sendTransaction } from \"../../../transaction/actions/send-transaction.js\";\nimport { waitForReceipt } from \"../../../transaction/actions/wait-for-tx-receipt.js\";\nimport { prepareTransaction } from \"../../../transaction/prepare-transaction.js\";\nimport { getAddress } from \"../../../utils/address.js\";\nimport { isEIP155Enforced } from \"../../../utils/any-evm/is-eip155-enforced.js\";\nimport { getKeylessTransaction } from \"../../../utils/any-evm/keyless-transaction.js\";\nimport { isContractDeployed } from \"../../../utils/bytecode/is-contract-deployed.js\";\nimport { withCache } from \"../../../utils/promise/withCache.js\";\nimport type {\n  ClientAndChain,\n  ClientAndChainAndAccount,\n} from \"../../../utils/types.js\";\nimport { getContract } from \"../../contract.js\";\n\nconst COMMON_FACTORY_ADDRESS = \"0x4e59b44847b379578588920cA78FbF26c0B4956C\"; // for pre-eip-155 supporting chains\n\n/**\n * @internal\n */\nconst CREATE2_FACTORY_BYTECODE =\n  \"0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3\";\n/**\n * @internal\n */\nconst SIGNATURE = {\n  v: 27n,\n  r: \"0x2222222222222222222222222222222222222222222222222222222222222222\",\n  s: \"0x2222222222222222222222222222222222222222222222222222222222222222\",\n} as const;\n\ntype Create2FactoryDeploymentInfo = {\n  valueToSend: bigint;\n  predictedAddress: `0x${string}`;\n  signerAddress: string;\n  transaction: `0x${string}`;\n};\n\n/**\n * Computes the address of the Create2 factory contract and checks if it is deployed.\n * @param options - The options for retrieving the Create2 factory address.\n * @returns whether the Create2 factory is deployed.\n * @internal\n */\nexport async function computeCreate2FactoryAddress(\n  options: ClientAndChain,\n): Promise<string> {\n  const chainId = options.chain.id;\n\n  return withCache(\n    async () => {\n      if (FACTORIES[chainId.toString()]) {\n        return FACTORIES[chainId.toString()] as string;\n      }\n      // special handling for chains with hardcoded gasPrice and gasLimit\n      if (CUSTOM_GAS_FOR_CHAIN[chainId]) {\n        const enforceEip155 = await isEIP155Enforced(options);\n        const eipChain = enforceEip155 ? chainId : 0;\n        const gasPrice = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]?.gasPrice;\n        const gasLimit = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]?.gasLimit;\n\n        const deploymentInfo = await _getCreate2FactoryDeploymentInfo(\n          eipChain,\n          {\n            gasPrice,\n            gasLimit,\n          },\n        );\n\n        return deploymentInfo.predictedAddress;\n      }\n\n      // default flow\n      const allBinsInfo = await Promise.all([\n        // to generate EIP-155 transaction\n        ...CUSTOM_GAS_BINS.map((b) => {\n          return _getCreate2FactoryDeploymentInfo(chainId, { gasPrice: b });\n        }),\n\n        // to generate pre EIP-155 transaction, hence chainId 0\n        ...CUSTOM_GAS_BINS.map((b) => {\n          return _getCreate2FactoryDeploymentInfo(0, { gasPrice: b });\n        }),\n      ]);\n\n      const allFactories = await Promise.all(\n        allBinsInfo.map((b) => {\n          const tempFactory = getContract({\n            ...options,\n            address: b.predictedAddress,\n          });\n          return isContractDeployed(tempFactory);\n        }),\n      );\n\n      const indexOfCommonFactory = allBinsInfo.findIndex(\n        (b) => b.predictedAddress === COMMON_FACTORY_ADDRESS,\n      );\n      if (indexOfCommonFactory && allFactories[indexOfCommonFactory]) {\n        return COMMON_FACTORY_ADDRESS;\n      }\n\n      const indexOfExistingDeployment = allFactories.findIndex((b) => b);\n      if (\n        indexOfExistingDeployment &&\n        allBinsInfo &&\n        allBinsInfo[indexOfExistingDeployment]?.predictedAddress\n      ) {\n        // TODO: cleanup\n        return allBinsInfo[indexOfExistingDeployment]\n          ?.predictedAddress as string;\n      }\n\n      const [enforceEip155, gasPriceFetched] = await Promise.all([\n        isEIP155Enforced(options),\n        getGasPrice(options),\n      ]);\n      const eipChain = enforceEip155 ? chainId : 0;\n      const bin = _getNearestGasPriceBin(gasPriceFetched);\n\n      const deploymentInfo = await _getCreate2FactoryDeploymentInfo(eipChain, {\n        gasPrice: bin,\n      });\n\n      return deploymentInfo.predictedAddress;\n    },\n    {\n      cacheKey: `create2factory:${chainId}`,\n      cacheTime: 24 * 60 * 60 * 1000, // 1 day\n    },\n  );\n}\n\n/**\n * @internal\n */\nexport async function getDeployedCreate2Factory(options: ClientAndChain) {\n  const address = await computeCreate2FactoryAddress(options);\n  const factory = getContract({\n    ...options,\n    address,\n  });\n  const isDeployed = await isContractDeployed(factory);\n  if (!isDeployed) {\n    return null;\n  }\n  return factory;\n}\n\n/**\n * Deploys the Create2 factory contract using a keyless transaction.\n * @internal\n */\nexport async function deployCreate2Factory(options: ClientAndChainAndAccount) {\n  const { client, chain, account } = options;\n  const enforceEip155 = await isEIP155Enforced(options);\n  const chainId = options.chain.id;\n  const eipChain = enforceEip155 ? chainId : 0;\n\n  const rpcRequest = getRpcClient({\n    client: client,\n    chain,\n  });\n\n  let gasPrice: bigint | undefined;\n  let gasLimit: bigint | undefined;\n\n  if (CUSTOM_GAS_FOR_CHAIN[chainId]) {\n    gasPrice = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]?.gasPrice;\n    gasLimit = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]?.gasLimit;\n  } else {\n    const gasPriceFetched = await getGasPrice(options);\n    gasPrice = _getNearestGasPriceBin(gasPriceFetched);\n  }\n\n  const deploymentInfo = await _getCreate2FactoryDeploymentInfo(eipChain, {\n    gasPrice,\n    gasLimit,\n  });\n\n  const balance = await eth_getBalance(rpcRequest, {\n    address: deploymentInfo.signerAddress,\n  });\n\n  if (balance < deploymentInfo.valueToSend) {\n    const transaction = prepareTransaction({\n      chain,\n      client,\n      to: deploymentInfo.signerAddress,\n      value: deploymentInfo.valueToSend,\n    });\n    const res = await sendTransaction({ transaction, account });\n    await waitForReceipt(res);\n  }\n  const transactionHash = await eth_sendRawTransaction(\n    rpcRequest,\n    deploymentInfo.transaction,\n  );\n  return {\n    transactionHash,\n  };\n}\n\n/**\n * Retrieves the deployment information for the Create2 factory contract.\n * @param chainId - The chain ID.\n * @param gasOptions - The gas options for the deployment transaction.\n * @returns The deployment information, including the deployment transaction and the create2 factory address.\n * @internal\n */\nasync function _getCreate2FactoryDeploymentInfo(\n  chainId: number,\n  gasOptions: { gasPrice?: bigint; gasLimit?: bigint },\n): Promise<Create2FactoryDeploymentInfo> {\n  // 100000 is default deployment gas limit and 100 gwei is default gas price for create2 factory deployment\n  // (See: https://github.com/Arachnid/deterministic-deployment-proxy?tab=readme-ov-file#deployment-gas-limit)\n  const gasPrice = gasOptions.gasPrice ? gasOptions.gasPrice : 100n * 10n ** 9n;\n  const gas = gasOptions.gasLimit ? gasOptions.gasLimit : 100000n;\n  const deploymentTransaction = await getKeylessTransaction({\n    transaction: {\n      gasPrice,\n      gas,\n      nonce: 0,\n      data: CREATE2_FACTORY_BYTECODE,\n      chainId: chainId !== 0 ? Number(chainId) : undefined,\n    },\n    signature: SIGNATURE,\n  });\n  const create2FactoryAddress = ox__ContractAddress.from({\n    from: deploymentTransaction.signerAddress,\n    nonce: 0n,\n  });\n\n  return {\n    ...deploymentTransaction,\n    valueToSend: gasPrice * gas,\n    predictedAddress: getAddress(create2FactoryAddress),\n  };\n}\n\nfunction _getNearestGasPriceBin(gasPrice: bigint): bigint {\n  return CUSTOM_GAS_BINS.find((e) => e >= gasPrice) || gasPrice;\n}\n\n// TODO: move this somewhere else\ntype CustomChain = {\n  name: string;\n  gasPrice?: bigint;\n  gasLimit?: bigint;\n};\n\nconst CUSTOM_GAS_FOR_CHAIN: Record<string, CustomChain> = {\n  \"5001\": {\n    name: \"Mantle Testnet\",\n    gasPrice: 1n,\n  },\n  \"71402\": {\n    name: \"Godwoken Mainnet\",\n    gasPrice: 40000n * 10n ** 9n,\n  },\n  \"1351057110\": {\n    name: \"Chaos (SKALE Testnet)\",\n    gasPrice: 100000n,\n  },\n  \"361\": {\n    name: \"Theta Mainnet\",\n    gasPrice: 4000n * 10n ** 9n,\n  },\n  \"365\": {\n    name: \"Theta Testnet\",\n    gasPrice: 4000n * 10n ** 9n,\n  },\n  \"7700\": {\n    name: \"Canto\",\n    gasPrice: 1000n * 10n ** 9n,\n  },\n  \"7701\": {\n    name: \"Canto Testnet\",\n    gasPrice: 1000n * 10n ** 9n,\n  },\n  \"338\": {\n    name: \"Cronos Testnet\",\n    gasPrice: 2000n * 10n ** 9n,\n  },\n  \"199\": {\n    name: \"BitTorrent Chain\",\n    gasPrice: 300000n * 10n ** 9n,\n  },\n  \"88882\": {\n    name: \"Spicy Chain\",\n    gasPrice: 2500n * 10n ** 9n,\n    gasLimit: 200000n,\n  },\n  \"88888\": {\n    name: \"Chiliz Chain\",\n    gasPrice: 2500n * 10n ** 9n,\n    gasLimit: 200000n,\n  },\n  // SKALE chains\n  \"1350216234\": {\n    name: \"Titan\",\n    gasPrice: 110000n,\n  },\n  \"1482601649\": {\n    name: \"Nebula\",\n    gasPrice: 110000n,\n  },\n  \"1564830818\": {\n    name: \"Calypso\",\n    gasPrice: 110000n,\n  },\n  \"2046399126\": {\n    name: \"Europa\",\n    gasPrice: 110000n,\n  },\n};\n\nconst FACTORIES: Record<string, string> = {\n  \"420120000\": COMMON_FACTORY_ADDRESS,\n  \"420120001\": COMMON_FACTORY_ADDRESS,\n  \"88888\": \"0xc501b9abf5540de1dd24f66633b1ecf35ff7101f\", // EIP155 is enforced, but the check fails, hence we hardcode the address here instead of computing dynamically\n};\n\nconst CUSTOM_GAS_BINS = [\n  1n,\n  1n * 10n ** 9n,\n  100n * 10n ** 9n,\n  500n * 10n ** 9n,\n  1000n * 10n ** 9n,\n  2500n * 10n ** 9n,\n  5000n * 10n ** 9n,\n  7500n * 10n ** 9n,\n  10_000n * 10n ** 9n,\n  25_000n * 10n ** 9n,\n  50_000n * 10n ** 9n,\n  75_000n * 10n ** 9n,\n  100_000n * 10n ** 9n,\n  250_000n * 10n ** 9n,\n  500_000n * 10n ** 9n,\n  750_000n * 10n ** 9n,\n  1_000_000n * 10n ** 9n,\n];\n", "import type { Hex } from \"../encoding/hex.js\";\nimport { stringToBytes } from \"../encoding/to-bytes.js\";\nimport { keccak256 } from \"../hashing/keccak256.js\";\n\n/**\n * Calculates the keccak ID of the given input.\n * @param input - The input value to calculate the keccak ID for.\n * @returns The keccak ID as a Hex string.\n * @example\n * ```ts\n * import { keccackId } from \"thirdweb/utils\";\n * const keccakId = keccackId(input);\n * ```\n * @utils\n */\nexport function keccakId(input: string): Hex {\n  return keccak256(stringToBytes(input));\n}\n", "import { ensureBytecodePrefix } from \"../bytecode/prefix.js\";\nimport type { Hex } from \"../encoding/hex.js\";\n\nimport { keccakId } from \"./keccak-id.js\";\n\n/**\n * Calculates the salt hash for a given bytecode.\n * @param bytecode - The bytecode to calculate the salt hash for.\n * @returns The salt hash of the bytecode.\n * @example\n * ```ts\n * import { getSaltHash } from \"thirdweb\";\n * const saltHash = getSaltHash(bytecode);\n * ```\n * @utils\n */\nexport function getSaltHash(bytecode: string): Hex {\n  const bytecodeHash = keccakId(ensureBytecodePrefix(bytecode));\n  const salt = `tw.${bytecodeHash}`;\n  return keccakId(salt);\n}\n", "import { type Hex, encodePacked } from \"viem\";\nimport { getAddress } from \"../address.js\";\nimport { ensureBytecodePrefix } from \"../bytecode/prefix.js\";\nimport { isHex } from \"../encoding/hex.js\";\nimport { keccak256 } from \"../hashing/keccak256.js\";\nimport { getSaltHash } from \"./get-salt-hash.js\";\nimport { keccakId } from \"./keccak-id.js\";\n\ntype ComputeDeploymentAddressOptions = {\n  bytecode: string;\n  encodedArgs: Hex;\n  create2FactoryAddress: string;\n  salt?: string;\n  extraDataWithUri?: Hex;\n};\n\n/**\n * Computes the deployment address for a contract based on the given options.\n * @param options - The options for computing the deployment address.\n * @returns The computed deployment address.\n * @example\n * ```ts\n * import { computeDeploymentAddress } from \"thirdweb/utils\";\n * const deploymentAddress = computeDeploymentAddress({\n *  bytecode,\n *  encodedArgs,\n *  create2FactoryAddress,\n *  salt,\n * });\n * ```\n * @utils\n */\nexport function computeDeploymentAddress(\n  options: ComputeDeploymentAddressOptions,\n) {\n  const bytecode = ensureBytecodePrefix(options.bytecode);\n  const saltHash = options.salt\n    ? isHex(options.salt) && options.salt.length === 66\n      ? options.salt\n      : keccakId(options.salt)\n    : getSaltHash(bytecode);\n\n  // 1. create init bytecode hash with contract's bytecode and encoded args\n  const initBytecode = options.extraDataWithUri\n    ? encodePacked(\n        [\"bytes\", \"bytes\", \"bytes\"],\n        [bytecode, options.encodedArgs, options.extraDataWithUri],\n      )\n    : encodePacked([\"bytes\", \"bytes\"], [bytecode, options.encodedArgs]);\n\n  // 2. abi-encode pack the deployer address, salt, and bytecode hash\n  const deployInfoPacked = encodePacked(\n    [\"bytes1\", \"address\", \"bytes32\", \"bytes32\"],\n    [\n      \"0xff\",\n      getAddress(options.create2FactoryAddress),\n      saltHash,\n      keccak256(encodePacked([\"bytes\"], [initBytecode])),\n    ],\n  );\n\n  // 3. hash the packed deploy info\n  const hashedDeployInfo = keccak256(\n    encodePacked([\"bytes\"], [deployInfoPacked]),\n  );\n\n  // 4. return last 20 bytes (40 characters) of the hash -- this is the predicted address\n  return `0x${hashedDeployInfo.slice(26)}`;\n}\n", "import { encodePacked } from \"viem/utils\";\nimport { ensureBytecodePrefix } from \"../bytecode/prefix.js\";\nimport { type Hex, isHex, uint8ArrayToHex } from \"../encoding/hex.js\";\nimport { getSaltHash } from \"./get-salt-hash.js\";\nimport { keccakId } from \"./keccak-id.js\";\n\ntype GetInitiBytecodeWithSaltOptions = {\n  bytecode: string;\n  encodedArgs: Hex | Uint8Array;\n  salt?: string;\n};\n\n/**\n * Generates the initialization bytecode with salt for a contract deployment.\n * @param options - The options for generating the initialization bytecode.\n * @returns The initialization bytecode with salt.\n * @example\n * ```ts\n * import { getInitBytecodeWithSalt } from \"thirdweb/utils\";\n * const initBytecodeWithSalt = getInitBytecodeWithSalt({\n *  bytecode,\n *  encodedArgs,\n *  salt,\n * });\n * ```\n * @utils\n */\nexport function getInitBytecodeWithSalt(\n  options: GetInitiBytecodeWithSaltOptions,\n): Hex {\n  const bytecode = ensureBytecodePrefix(options.bytecode);\n\n  const saltHash = options.salt\n    ? isHex(options.salt) && options.salt.length === 66\n      ? options.salt\n      : keccakId(options.salt)\n    : getSaltHash(bytecode);\n\n  const encodedArgs =\n    typeof options.encodedArgs === \"string\"\n      ? options.encodedArgs\n      : uint8ArrayToHex(options.encodedArgs);\n\n  return encodePacked(\n    [\"bytes32\", \"bytes\", \"bytes\"],\n    [saltHash, bytecode, encodedArgs],\n  );\n}\n", "const function_cache = new Map<string, string>();\nconst event_cache = new Map<string, string>();\n\ntype FunctionString = `function ${string}`;\ntype EventString = `event ${string}`;\n\n// TODO: investigate a better source for this\nconst SIGNATURE_API = \"https://www.4byte.directory/api/v1\";\n\nasync function resolveFunctionSignature(\n  hexSig: string,\n): Promise<FunctionString | null> {\n  if (function_cache.has(hexSig)) {\n    return function_cache.get(hexSig) as FunctionString;\n  }\n  const res = await fetch(\n    `${SIGNATURE_API}/signatures/?format=json&hex_signature=${hexSig}`,\n  );\n  if (!res.ok) {\n    return null;\n  }\n  const data = await res.json();\n  if (data.count === 0) {\n    return null;\n  }\n  const signature = `function ${data.results[0].text_signature}` as const;\n  function_cache.set(hexSig, signature);\n  return signature;\n}\n\nasync function resolveEventSignature(\n  hexSig: string,\n): Promise<EventString | null> {\n  if (event_cache.has(hexSig)) {\n    return event_cache.get(hexSig) as EventString;\n  }\n  const res = await fetch(\n    `${SIGNATURE_API}/event-signatures/?format=json&hex_signature=${hexSig}`,\n  );\n  if (!res.ok) {\n    return null;\n  }\n  const data = await res.json();\n  if (data.count === 0) {\n    return null;\n  }\n\n  const signature = `event ${uppercaseFirstLetter(\n    data.results[0].text_signature,\n  )}` as const;\n  event_cache.set(hexSig, signature);\n  return signature;\n}\n// helper\nfunction uppercaseFirstLetter(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n/**\n * Resolves a signature by converting a hexadecimal string into a function or event signature.\n * @param hexSig The hexadecimal signature to resolve.\n * @returns A promise that resolves to an object containing the function and event signatures.\n * @example\n * ```ts\n * import { resolveSignature } from \"thirdweb/utils\";\n * const res = await resolveSignature(\"0x1f931c1c\");\n * console.log(res);\n * ```\n * @utils\n */\nexport async function resolveSignature(hexSig: string): Promise<{\n  function: FunctionString | null;\n  event: EventString | null;\n}> {\n  if (hexSig.startsWith(\"0x\")) {\n    // biome-ignore lint/style/noParameterAssign: modifying in-place for performance\n    hexSig = hexSig.slice(2);\n  }\n  const all = await Promise.all([\n    resolveFunctionSignature(hexSig),\n    resolveEventSignature(hexSig),\n  ]);\n  return {\n    function: all[0],\n    event: all[1],\n  };\n}\n\n/**\n * Resolves the signatures of the given hexadecimal signatures.\n * @param hexSigs An array of hexadecimal signatures.\n * @returns A promise that resolves to an object containing the resolved functions and events.\n * @example\n * ```ts\n * import { resolveSignatures } from \"thirdweb/utils\";\n * const res = await resolveSignatures([\"0x1f931c1c\", \"0x1f931c1c\"]);\n * console.log(res);\n * ```\n * @utils\n */\nexport async function resolveSignatures(hexSigs: string[]): Promise<{\n  functions: FunctionString[];\n  events: EventString[];\n}> {\n  // dedupe hexSigs\n  // biome-ignore lint/style/noParameterAssign: modifying in-place for performance\n  hexSigs = Array.from(new Set(hexSigs));\n  const all = await Promise.all(\n    hexSigs.map((hexSig) => resolveSignature(hexSig)),\n  );\n  return {\n    functions: all\n      .map((x) => x.function)\n      .filter((x) => x !== null)\n      .sort() as FunctionString[],\n    events: all\n      .map((x) => x.event)\n      .filter((x) => x !== null)\n      .sort() as EventString[],\n  };\n}\n\n/**\n * @internal\n */\nexport function clearCache() {\n  function_cache.clear();\n  event_cache.clear();\n}\n", "import * as ox__Secp256k1 from \"ox/Secp256k1\";\n\nimport { type Hex, toHex } from \"../encoding/hex.js\";\n\n/**\n * Options for signing a transaction hash.\n */\nexport type SignOptions = {\n  hash: Hex;\n  privateKey: Hex;\n};\n\n/**\n * Generates the signature for the provided transaction hash.\n * @param options - The options for signing.\n * @param options.hash - The hash to be signed.\n * @param options.privateKey - The private key to sign the hash with.\n * @returns The transaction signature.\n * @example\n * ```ts\n * import { sign } from \"thirdweb/utils\";\n *\n * const signature = sign({\n *   hash: \"0x\",\n *   privateKey: \"0x\",\n * });\n * ```\n * @utils\n */\nexport function sign({ hash, privateKey }: SignOptions) {\n  const { r, s, yParity } = ox__Secp256k1.sign({ payload: hash, privateKey });\n  return {\n    r: toHex(r, { size: 32 }),\n    s: toHex(s, { size: 32 }),\n    v: yParity === 1 ? 28n : 27n,\n    yParity,\n  };\n}\n", "import * as ox__Hex from \"ox/Hex\";\nimport * as ox__Signature from \"ox/Signature\";\nimport type { Hex } from \"../encoding/hex.js\";\n\n/**\n * Converts a signature to a hex string.\n * @param signature The signature to convert.\n * @returns The hex string representation of the signature.\n * @example\n * ```ts\n * import { signatureToHex } from \"thirdweb/utils\";\n *\n * const hex = signatureToHex({\n * r: toHex(\n * 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * ),\n * s: toHex(\n * 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * ),\n * v: 28n,\n * });\n *\n * console.log(hex);\n * // \"0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c\"\n * ```\n * @utils\n */\nexport function signatureToHex(signature: {\n  r: Hex;\n  s: Hex;\n  v?: bigint | number | Hex | undefined;\n  yParity?: bigint | number | Hex | undefined;\n}): Hex {\n  const { r, s, v, yParity } = signature;\n  return ox__Signature.toHex(\n    ox__Signature.from(\n      typeof yParity !== \"undefined\"\n        ? {\n            r,\n            s,\n            yParity: !ox__Hex.validate(yParity)\n              ? ox__Hex.fromNumber(yParity)\n              : yParity,\n          }\n        : {\n            r,\n            s,\n            v:\n              !ox__Hex.validate(v) && typeof v !== \"undefined\"\n                ? ox__Hex.fromNumber(v)\n                : v,\n          },\n    ),\n  );\n}\n", "import * as abitype from 'abitype'\nimport type * as Abi from './Abi.js'\nimport * as AbiItem from './AbiItem.js'\nimport * as AbiParameters from './AbiParameters.js'\nimport type * as Errors from './Errors.js'\nimport * as Hex from './Hex.js'\nimport type * as internal from './internal/abiError.js'\nimport type * as AbiItem_internal from './internal/abiItem.js'\nimport type { IsNarrowable, IsNever } from './internal/types.js'\n\n/** Root type for an {@link ox#AbiItem.AbiItem} with an `error` type. */\nexport type AbiError = abitype.AbiError & {\n  hash?: Hex.Hex | undefined\n  overloads?: readonly AbiError[] | undefined\n}\n\n/** @internal */\nexport function decode<\n  const abiError extends AbiError,\n  as extends 'Object' | 'Array' = 'Array',\n>(\n  abiError: abiError,\n  data: Hex.Hex,\n  options?: decode.Options<as> | undefined,\n): decode.ReturnType<abiError, as>\n/**\n * ABI-decodes the provided error input (`inputs`).\n *\n * :::tip\n *\n * This function is typically used to decode contract function reverts (e.g. a JSON-RPC error response).\n *\n * See the [End-to-end Example](#end-to-end).\n *\n * :::\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from('error InvalidSignature(uint r, uint s, uint8 yParity)')\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001')\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * You can extract an ABI Error from a JSON ABI with {@link ox#AbiError.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([...]) // [!code hl]\n * const error = AbiError.fromAbi(abi, 'InvalidSignature') // [!code hl]\n *\n * const value = AbiError.decode(error, '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001')\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * You can pass the error `data` to the `name` property of {@link ox#AbiError.(fromAbi:function)} to extract and infer the error by its 4-byte selector:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const data = '0xecde634900000000000000000000000000000000000000000000000000000000000001a400000000000000000000000000000000000000000000000000000000000000450000000000000000000000000000000000000000000000000000000000000001'\n *\n * const abi = Abi.from([...])\n * const error = AbiError.fromAbi(abi, data) // [!code hl]\n *\n * const value = AbiError.decode(error, data)\n * // @log: [420n, 69n, 1]\n * ```\n *\n * @example\n * ### End-to-end\n *\n * Below is an end-to-end example of using `AbiError.decode` to decode the revert error of an `approve` contract call on the [Wagmi Mint Example contract](https://etherscan.io/address/0xfba3912ca04dd458c843e2ee08967fc04f3579c2).\n *\n * ```ts twoslash\n * // @noErrors\n * import 'ox/window'\n * import { Abi, AbiError, AbiFunction } from 'ox'\n *\n * // 1. Extract the Function from the Contract's ABI.\n * const abi = Abi.from([\n *   // ...\n *   {\n *     inputs: [\n *       { name: 'to', type: 'address' },\n *       { name: 'tokenId', type: 'uint256' },\n *     ],\n *     name: 'approve',\n *     outputs: [],\n *     stateMutability: 'nonpayable',\n *     type: 'function',\n *   },\n *   // ...\n * ])\n * const approve = AbiFunction.fromAbi(abi, 'approve')\n *\n * // 2. Encode the Function Input.\n * const data = AbiFunction.encodeData(\n *   approve,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n *\n * try {\n *   // 3. Attempt to perform the the Contract Call.\n *   await window.ethereum!.request({\n *     method: 'eth_call',\n *     params: [\n *       {\n *         data,\n *         to: '0xfba3912ca04dd458c843e2ee08967fc04f3579c2',\n *       },\n *     ],\n *   })\n * } catch (e) { // [!code focus]\n *   // 4. Extract and decode the Error. // [!code focus]\n *   const error = AbiError.fromAbi(abi, e.data) // [!code focus]\n *   const value = AbiError.decode(error, e.data) // [!code focus]\n *   console.error(`${error.name}(${value})`) // [!code focus]\n * // @error:   Error(ERC721: approve caller is not owner nor approved for all)\n * } // [!code focus]\n * ```\n *\n * :::note\n *\n * For simplicity, the above example uses `window.ethereum.request`, but you can use any\n * type of JSON-RPC interface.\n *\n * :::\n *\n * @param abiError - The ABI Error to decode.\n * @param data - The error data.\n * @param options - Decoding options.\n * @returns The decoded error.\n */\nexport function decode(\n  abiError: AbiError,\n  data: Hex.Hex,\n  options?: decode.Options | undefined,\n): unknown | readonly unknown[] | undefined\n/** @internal */\nexport function decode(\n  abiError: AbiError,\n  data: Hex.Hex,\n  options: decode.Options = {},\n): decode.ReturnType {\n  if (Hex.size(data) < 4) throw new AbiItem.InvalidSelectorSizeError({ data })\n  if (abiError.inputs.length === 0) return undefined\n\n  const values = AbiParameters.decode(\n    abiError.inputs,\n    Hex.slice(data, 4),\n    options,\n  )\n  if (values && Object.keys(values).length === 1) {\n    if (Array.isArray(values)) return values[0]\n    return Object.values(values)[0]\n  }\n  return values\n}\n\nexport declare namespace decode {\n  type Options<as extends 'Object' | 'Array' = 'Array'> = {\n    /**\n     * Whether the decoded values should be returned as an `Object` or `Array`.\n     *\n     * @default \"Array\"\n     */\n    as?: as | 'Array' | 'Object' | undefined\n  }\n\n  type ReturnType<\n    abiError extends AbiError = AbiError,\n    as extends 'Object' | 'Array' = 'Array',\n  > = IsNarrowable<abiError, AbiError> extends true\n    ? abiError['inputs'] extends readonly []\n      ? undefined\n      : abiError['inputs'] extends readonly [\n            infer type extends abitype.AbiParameter,\n          ]\n        ? abitype.AbiParameterToPrimitiveType<type>\n        : AbiParameters.decode.ReturnType<\n              abiError['inputs'],\n              as\n            > extends infer types\n          ? types extends readonly []\n            ? undefined\n            : types extends readonly [infer type]\n              ? type\n              : types\n          : never\n    : unknown | readonly unknown[] | undefined\n\n  type ErrorType =\n    | AbiParameters.decode.ErrorType\n    | Hex.size.ErrorType\n    | typeof AbiItem.InvalidSelectorSizeError\n    | Errors.GlobalErrorType\n}\n\n/**\n * ABI-encodes the provided error input (`inputs`), prefixed with the 4 byte error selector.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const error = AbiError.from(\n *   'error InvalidSignature(uint r, uint s, uint8 yParity)'\n * )\n *\n * const data = AbiError.encode( // [!code focus]\n *   error, // [!code focus]\n *   [1n, 2n, 0] // [!code focus]\n * ) // [!code focus]\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @example\n * You can extract an ABI Error from a JSON ABI with {@link ox#AbiError.(fromAbi:function)}:\n *\n * ```ts twoslash\n * // @noErrors\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([ // [!code hl]\n *   // ... // [!code hl]\n *   { // [!code hl]\n *     name: 'InvalidSignature', // [!code hl]\n *     type: 'error', // [!code hl]\n *     inputs: [ // [!code hl]\n *       { name: 'r', type: 'uint256' }, // [!code hl]\n *       { name: 's', type: 'uint256' }, // [!code hl]\n *       { name: 'yParity', type: 'uint8' }, // [!code hl]\n *     ], // [!code hl]\n *   }, // [!code hl]\n *   // ... // [!code hl]\n * ]) // [!code hl]\n * const error = AbiError.fromAbi(abi, 'InvalidSignature') // [!code hl]\n *\n * const data = AbiError.encode(\n *   error,\n *   ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 69420n]\n * )\n * // @log: '0x095ea7b3000000000000000000000000d8da6bf26964af9d7eed9e03e53415d37aa960450000000000000000000000000000000000000000000000000000000000010f2c'\n * ```\n *\n * @param abiError - ABI Error to encode\n * @param args - Error arguments\n * @returns ABI-encoded error name and arguments\n */\nexport function encode<const abiError extends AbiError>(\n  abiError: abiError,\n  ...args: encode.Args<abiError>\n): encode.ReturnType {\n  const selector = getSelector(abiError)\n\n  const data =\n    args.length > 0\n      ? AbiParameters.encode(abiError.inputs, (args as any)[0])\n      : undefined\n\n  return data ? Hex.concat(selector, data) : selector\n}\n\nexport declare namespace encode {\n  type Args<abiError extends AbiError = AbiError> = IsNarrowable<\n    abiError,\n    AbiError\n  > extends true\n    ? abitype.AbiParametersToPrimitiveTypes<\n        abiError['inputs']\n      > extends readonly []\n      ? []\n      : [abitype.AbiParametersToPrimitiveTypes<abiError['inputs']>]\n    : readonly unknown[]\n\n  type ReturnType = Hex.Hex\n\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Formats an {@link ox#AbiError.AbiError} into a **Human Readable ABI Error**.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const formatted = AbiError.format({\n *   type: 'error',\n *   name: 'Example',\n *   inputs: [\n *     {\n *       name: 'spender',\n *       type: 'address',\n *     },\n *     {\n *       name: 'amount',\n *       type: 'uint256',\n *     },\n *   ],\n * })\n *\n * formatted\n * //    ^?\n *\n *\n * ```\n *\n * @param abiError - The ABI Error to format.\n * @returns The formatted ABI Error.\n */\nexport function format<const abiError extends AbiError>(\n  abiError: abiError | AbiError,\n): abitype.FormatAbiItem<abiError> {\n  return abitype.formatAbiItem(abiError) as never\n}\n\nexport declare namespace format {\n  type ErrorType = Errors.GlobalErrorType\n}\n\n/**\n * Parses an arbitrary **JSON ABI Error** or **Human Readable ABI Error** into a typed {@link ox#AbiError.AbiError}.\n *\n * @example\n * ### JSON ABIs\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from({\n *   inputs: [{ name: 'v', type: 'uint8' }],\n *   name: 'BadSignatureV',\n *   type: 'error',\n * })\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Human Readable ABIs\n *\n * A Human Readable ABI can be parsed into a typed ABI object:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from(\n *   'error BadSignatureV(uint8 v)' // [!code hl]\n * )\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * It is possible to specify `struct`s along with your definitions:\n *\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const badSignatureVError = AbiError.from([\n *   'struct Signature { uint8 v; }', // [!code hl]\n *   'error BadSignatureV(Signature signature)',\n * ])\n *\n * badSignatureVError\n * //^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n *\n *\n * @param abiError - The ABI Error to parse.\n * @returns Typed ABI Error.\n */\nexport function from<\n  const abiError extends AbiError | string | readonly string[],\n>(\n  abiError: (abiError | AbiError | string | readonly string[]) &\n    (\n      | (abiError extends string ? internal.Signature<abiError> : never)\n      | (abiError extends readonly string[]\n          ? internal.Signatures<abiError>\n          : never)\n      | AbiError\n    ),\n  options: from.Options = {},\n): from.ReturnType<abiError> {\n  return AbiItem.from(abiError as AbiError, options) as never\n}\n\nexport declare namespace from {\n  type Options = {\n    /**\n     * Whether or not to prepare the extracted function (optimization for encoding performance).\n     * When `true`, the `hash` property is computed and included in the returned value.\n     *\n     * @default true\n     */\n    prepare?: boolean | undefined\n  }\n\n  type ReturnType<abiError extends AbiError | string | readonly string[]> =\n    AbiItem.from.ReturnType<abiError>\n\n  type ErrorType = AbiItem.from.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Extracts an {@link ox#AbiError.AbiError} from an {@link ox#Abi.Abi} given a name and optional arguments.\n *\n * @example\n * ### Extracting by Name\n *\n * ABI Errors can be extracted by their name using the `name` option:\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n *\n * const item = AbiError.fromAbi(abi, 'BadSignatureV') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n * ```\n *\n * @example\n * ### Extracting by Selector\n *\n * ABI Errors can be extract by their selector when {@link ox#Hex.Hex} is provided to `name`.\n *\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'function foo()',\n *   'error BadSignatureV(uint8 v)',\n *   'function bar(string a) returns (uint256 x)',\n * ])\n * const item = AbiError.fromAbi(abi, '0x095ea7b3') // [!code focus]\n * //    ^?\n *\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n *\n * :::note\n *\n * Extracting via a hex selector is useful when extracting an ABI Error from JSON-RPC error data.\n *\n * :::\n *\n * @param abi - The ABI to extract from.\n * @param name - The name (or selector) of the ABI item to extract.\n * @param options - Extraction options.\n * @returns The ABI item.\n */\nexport function fromAbi<\n  const abi extends Abi.Abi | readonly unknown[],\n  name extends Name<abi>,\n  const args extends\n    | AbiItem_internal.ExtractArgs<abi, name>\n    | undefined = undefined,\n  //\n  allNames = Name<abi>,\n>(\n  abi: abi | Abi.Abi | readonly unknown[],\n  name: Hex.Hex | (name extends allNames ? name : never),\n  options?: AbiItem.fromAbi.Options<\n    abi,\n    name,\n    args,\n    AbiItem_internal.ExtractArgs<abi, name>\n  >,\n): fromAbi.ReturnType<abi, name, args> {\n  if (name === 'Error') return solidityError as never\n  if (name === 'Panic') return solidityPanic as never\n  if (Hex.validate(name, { strict: false })) {\n    const selector = Hex.slice(name, 0, 4)\n    if (selector === solidityErrorSelector) return solidityError as never\n    if (selector === solidityPanicSelector) return solidityPanic as never\n  }\n\n  const item = AbiItem.fromAbi(abi, name, options as any)\n  if (item.type !== 'error')\n    throw new AbiItem.NotFoundError({ name, type: 'error' })\n  return item as never\n}\n\nexport declare namespace fromAbi {\n  type ReturnType<\n    abi extends Abi.Abi | readonly unknown[] = Abi.Abi,\n    name extends Name<abi> = Name<abi>,\n    args extends\n      | AbiItem_internal.ExtractArgs<abi, name>\n      | undefined = AbiItem_internal.ExtractArgs<abi, name>,\n  > = IsNarrowable<name, Name<abi>> extends true\n    ?\n        | (name extends 'Error' ? typeof solidityError : never)\n        | (name extends 'Panic'\n            ? typeof solidityPanic\n            : never) extends infer result\n      ? IsNever<result> extends true\n        ? AbiItem.fromAbi.ReturnType<abi, name, args, AbiError>\n        : result\n      : never\n    :\n        | AbiItem.fromAbi.ReturnType<abi, name, args, AbiError>\n        | typeof solidityError\n        | typeof solidityPanic\n\n  type ErrorType = AbiItem.fromAbi.ErrorType | Errors.GlobalErrorType\n}\n\n/**\n * Computes the [4-byte selector](https://solidity-by-example.org/function-selector/) for an {@link ox#AbiError.AbiError}.\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const selector = AbiError.getSelector('error BadSignatureV(uint8 v)')\n * // @log: '0x6352211e'\n * ```\n *\n * @example\n * ```ts twoslash\n * import { AbiError } from 'ox'\n *\n * const selector = AbiError.getSelector({\n *   inputs: [{ name: 'v', type: 'uint8' }],\n *   name: 'BadSignatureV',\n *   type: 'error'\n * })\n * // @log: '0x6352211e'\n * ```\n *\n * @param abiItem - The ABI item to compute the selector for.\n * @returns The first 4 bytes of the {@link ox#Hash.(keccak256:function)} hash of the error signature.\n */\nexport function getSelector(abiItem: string | AbiError): Hex.Hex {\n  return AbiItem.getSelector(abiItem)\n}\n\nexport declare namespace getSelector {\n  type ErrorType = AbiItem.getSelector.ErrorType | Errors.GlobalErrorType\n}\n\n// https://docs.soliditylang.org/en/v0.8.16/control-structures.html#panic-via-assert-and-error-via-require\nexport const panicReasons = {\n  1: 'An `assert` condition failed.',\n  17: 'Arithmetic operation resulted in underflow or overflow.',\n  18: 'Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).',\n  33: 'Attempted to convert to an invalid type.',\n  34: 'Attempted to access a storage byte array that is incorrectly encoded.',\n  49: 'Performed `.pop()` on an empty array',\n  50: 'Array index is out of bounds.',\n  65: 'Allocated too much memory or created an array which is too large.',\n  81: 'Attempted to call a zero-initialized variable of internal function type.',\n} as Record<number, string>\n\nexport const solidityError = /*#__PURE__*/ from({\n  inputs: [\n    {\n      name: 'message',\n      type: 'string',\n    },\n  ],\n  name: 'Error',\n  type: 'error',\n})\n\nexport const solidityErrorSelector = '0x08c379a0'\n\nexport const solidityPanic = /*#__PURE__*/ from({\n  inputs: [\n    {\n      name: 'reason',\n      type: 'uint8',\n    },\n  ],\n  name: 'Panic',\n  type: 'error',\n})\n\nexport const solidityPanicSelector = '0x4e487b71'\n\n/**\n * Extracts an {@link ox#AbiError.AbiError} item from an {@link ox#Abi.Abi}, given a name.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'error Bar(uint256)',\n * ])\n *\n * type Foo = AbiError.FromAbi<typeof abi, 'Foo'>\n * //   ^?\n *\n *\n *\n *\n *\n *\n *\n *\n * ```\n */\nexport type FromAbi<\n  abi extends Abi.Abi,\n  name extends ExtractNames<abi>,\n> = abitype.ExtractAbiError<abi, name>\n\n/**\n * Extracts the names of all {@link ox#AbiError.AbiError} items in an {@link ox#Abi.Abi}.\n *\n * @example\n * ```ts twoslash\n * import { Abi, AbiError } from 'ox'\n *\n * const abi = Abi.from([\n *   'error Foo(string)',\n *   'error Bar(uint256)',\n * ])\n *\n * type names = AbiError.Name<typeof abi>\n * //   ^?\n * ```\n */\nexport type Name<abi extends Abi.Abi | readonly unknown[] = Abi.Abi> =\n  abi extends Abi.Abi ? ExtractNames<abi> : string\n\nexport type ExtractNames<abi extends Abi.Abi> =\n  | abitype.ExtractAbiErrorNames<abi>\n  | 'Panic'\n  | 'Error'\n", "import type * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiError from \"ox/AbiError\";\nimport { resolveContractAbi } from \"../../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\nimport type { Hex } from \"../encoding/hex.js\";\n\n/**\n * Decodes an error.\n * @param options - The options object.\n * @returns The decoded error.\n * @example\n * ```ts\n * import { decodeError } from \"thirdweb/utils\";\n *\n * const data = \"0x...\";\n * const error = await decodeError({ contract, data });\n * ```\n *\n * @utils\n */\nexport async function decodeError<abi extends ox__Abi.Abi>(options: {\n  contract: ThirdwebContract<abi>;\n  data: Hex;\n}) {\n  const { contract, data } = options;\n  let abi = contract?.abi;\n  if (contract && !abi) {\n    abi = await resolveContractAbi(contract).catch(() => undefined);\n  }\n  if (!abi) {\n    throw new Error(\n      `No ABI found for contract ${contract.address} on chain ${contract.chain.id}`,\n    );\n  }\n  const abiError = ox__AbiError.fromAbi(abi, data) as ox__AbiError.AbiError;\n  return ox__AbiError.decode(abiError, data);\n}\n", "import type * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport type * as ox__Hex from \"ox/Hex\";\nimport { resolveContractAbi } from \"../../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\n\n/**\n * Decodes the data of a function call.\n * @param options - The options object.\n * @returns The decoded data.\n * @example\n * ```ts\n * import { decodeFunctionData } from \"thirdweb/utils\";\n *\n * const data = \"0x...\";\n * const decodedData = await decodeFunctionData({ contract, data });\n * ```\n *\n * @utils\n */\nexport async function decodeFunctionData<abi extends ox__Abi.Abi>(options: {\n  contract: ThirdwebContract<abi>;\n  data: ox__Hex.Hex;\n}) {\n  const { contract, data } = options;\n  let abi = contract?.abi;\n  if (contract && !abi) {\n    abi = await resolveContractAbi(contract).catch(() => undefined);\n  }\n  if (!abi) {\n    throw new Error(\n      `No ABI found for contract ${contract.address} on chain ${contract.chain.id}`,\n    );\n  }\n  const abiFunction = ox__AbiFunction.fromAbi(abi, data);\n  return ox__AbiFunction.decodeData(abiFunction, data);\n}\n", "import type * as ox__Abi from \"ox/Abi\";\nimport * as ox__AbiFunction from \"ox/AbiFunction\";\nimport type * as ox__Hex from \"ox/Hex\";\nimport { resolveContractAbi } from \"../../contract/actions/resolve-abi.js\";\nimport type { ThirdwebContract } from \"../../contract/contract.js\";\n\n/**\n * Decodes the result of a function call.\n * @param options - The options object.\n * @returns The decoded result.\n * @example\n * ```ts\n * import { decodeFunctionResult } from \"thirdweb/utils\";\n *\n * const data = \"0x...\";\n * const result = await decodeFunctionResult({ contract, data });\n * ```\n *\n * @utils\n */\nexport async function decodeFunctionResult<abi extends ox__Abi.Abi>(options: {\n  contract: ThirdwebContract<abi>;\n  data: ox__Hex.Hex;\n}) {\n  const { contract, ...rest } = options;\n  let abi = contract?.abi;\n  if (contract && !abi) {\n    abi = await resolveContractAbi(contract).catch(() => undefined);\n  }\n  if (!abi) {\n    throw new Error(\n      `No ABI found for contract ${contract.address} on chain ${contract.chain.id}`,\n    );\n  }\n  const abiFunction = ox__AbiFunction.fromAbi(abi, rest.data);\n  return ox__AbiFunction.decodeResult(abiFunction, rest.data);\n}\n", "/**\n * This is a precompile of the header for the JWT generated via:\n * ```ts\n * uint8ArrayToBase64(\n * stringToBytes(JSON.stringify(RAW_HEADER)),\n * )\n * ```\n */\nexport const PRECOMPILED_B64_ENCODED_JWT_HEADER =\n  \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9\";\n", "import type { Hex } from \"../encoding/hex.js\";\nimport { base64ToString } from \"../uint8-array.js\";\nimport { PRECOMPILED_B64_ENCODED_JWT_HEADER } from \"./jwt-header.js\";\nimport type { JWTPayload } from \"./types.js\";\n\n/**\n * Decodes a JSON Web Token (JWT) and returns the decoded payload and signature.\n * @param jwt - The JWT string to decode.\n * @returns An object containing the decoded payload and signature.\n * @throws {Error} If the JWT header is invalid or if the JWT is invalid.\n * @example\n * ```ts\n * import { decodeJWT } from 'thirdweb/utils';\n *\n * const { payload, signature } = decodeJWT(jwt);\n * ```\n * @auth\n */\nexport function decodeJWT(jwt: string) {\n  const [encodedHeader, encodedPayload, encodedSignature] = jwt.split(\".\");\n\n  if (encodedHeader !== PRECOMPILED_B64_ENCODED_JWT_HEADER) {\n    throw new Error(\"Invalid JWT header\");\n  }\n  if (!encodedPayload || !encodedSignature) {\n    throw new Error(\"Invalid JWT\");\n  }\n\n  const payload: JWTPayload = JSON.parse(base64ToString(encodedPayload));\n  const signature = base64ToString(encodedSignature) as Hex;\n\n  return {\n    payload,\n    signature,\n  };\n}\n", "import type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { stringToBytes } from \"../encoding/to-bytes.js\";\nimport { stringify } from \"../json.js\";\nimport { randomBytesHex } from \"../random.js\";\nimport { uint8ArrayToBase64 } from \"../uint8-array.js\";\nimport { PRECOMPILED_B64_ENCODED_JWT_HEADER } from \"./jwt-header.js\";\nimport type { JWTPayload } from \"./types.js\";\n\nexport type JWTPayloadInput<Tctx = unknown> = {\n  iss: string;\n  sub: string;\n  aud: string;\n  exp: Date;\n  nbf: Date;\n  iat: Date;\n  jti?: string;\n  ctx?: Tctx;\n};\n\ntype EncodeJWTParams = { payload: JWTPayloadInput; account: Account };\n\n/**\n * Builds a JSON Web Token (JWT) using the provided options.\n * @param options - The options for building the JWT.\n * @returns The generated JWT.\n * @throws Error if the account is not found.\n * @example\n * ```ts\n * import { encodeJWT } from 'thirdweb/utils';\n *\n * const jwt = await encodeJWT({\n *  payload: {\n *    iss: '0x1234567890123456789012345678901234567890',\n *    sub: '0x1234567890123456789012345678901234567890',\n *    aud: '0x1234567890123456789012345678901234567890',\n *    exp: new Date(Date.now() + 1000 * 60 * 60),\n *    nbf: new Date(),\n *    iat: new Date(),\n *    jti: '1234567890',\n *    ctx: {\n *        example: 'example',\n *    },\n *  },\n *  wallet,\n * });\n * ```\n * @auth\n */\nexport async function encodeJWT(options: EncodeJWTParams) {\n  const payload = await ensureJWTPayload(options.payload);\n  const message = stringify(payload);\n\n  const signature = await options.account.signMessage({ message });\n\n  const encodedData = uint8ArrayToBase64(stringToBytes(message), {\n    urlSafe: true,\n  });\n\n  const encodedSignature = uint8ArrayToBase64(stringToBytes(signature), {\n    urlSafe: true,\n  });\n\n  // Generate a JWT with base64 encoded header, payload, and signature\n  return `${PRECOMPILED_B64_ENCODED_JWT_HEADER}.${encodedData}.${encodedSignature}`;\n}\n\nasync function ensureJWTPayload(payload: JWTPayloadInput): Promise<JWTPayload> {\n  return {\n    iss: payload.iss,\n    sub: payload.sub,\n    aud: payload.aud,\n    exp: Math.floor(payload.exp.getTime() / 1000),\n    nbf: Math.floor(payload.nbf.getTime() / 1000),\n    iat: Math.floor(payload.iat.getTime() / 1000),\n    // default to uuid if jti is not provided\n    jti: payload.jti || (await randomBytesHex()),\n    ctx: payload.ctx,\n  };\n}\n", "import type { Account } from \"../../wallets/interfaces/wallet.js\";\nimport { decodeJWT } from \"./decode-jwt.js\";\nimport { encodeJWT } from \"./encode-jwt.js\";\n\nconst DEFAULT_EXPIRATION_TIME = 60 * 60 * 24;\n\nexport type RefreshJWTParams = {\n  account: Account;\n  jwt: string;\n  expirationTime?: number;\n};\n\n/**\n * Refreshes a JSON Web Token (JWT) by encoding a new payload with updated expiration time.\n * @param options - The options for refreshing the JWT.\n * @returns A Promise that resolves to the refreshed JWT.\n * @example\n * ```ts\n * import { refreshJWT } from 'thirdweb/utils';\n *\n * const jwt = await refreshJWT({\n *  account,\n *  jwt,\n *  expirationTime: 1000 * 60 * 60,\n * });\n * ```\n * @auth\n */\nexport async function refreshJWT(options: RefreshJWTParams): Promise<string> {\n  const { account, jwt, expirationTime = DEFAULT_EXPIRATION_TIME } = options;\n  const payload = decodeJWT(jwt).payload;\n  return encodeJWT({\n    payload: {\n      iss: payload.iss,\n      sub: payload.sub,\n      aud: payload.aud,\n      nbf: new Date(),\n      exp: new Date(Date.now() + expirationTime),\n      iat: new Date(),\n      ctx: payload.ctx,\n    },\n    account,\n  });\n}\n", "import { isAddress } from \"../address.js\";\nimport { isHex, padHex } from \"../encoding/hex.js\";\n\n/**\n * Converts an array of parameter values to their respective types based on the provided type array.\n *\n * This utility function is particularly useful for ensuring that parameter values are correctly formatted\n * according to the expected types before they are used in further processing or passed to a Solidity smart contract.\n *\n * @param {string[]} constructorParamTypes - An array of type strings indicating the expected types of the values,\n *                   following Solidity type conventions (e.g., \"address\", \"uint256\", \"bool\").\n * @param {unknown[]} constructorParamValues - An array of values to be converted according to the types.\n * @returns - An array of values converted to their respective types.\n *\n * @example\n * ```ts\n * import { parseAbiParams } from \"thirdweb/utils\";\n *\n * const example1 = parseAbiParams(\n *   [\"address\", \"uint256\"],\n *   [\"0x.....\", \"1200000\"]\n * ); // result: [\"0x......\", 1200000n]\n *\n * const example2 = parseAbiParams(\n *   [\"address\", \"bool\"],\n *   [\"0x.....\", \"true\"]\n * ); // result: [\"0x......\", true]\n * ```\n * @utils\n */\nexport function parseAbiParams(\n  constructorParamTypes: string[],\n  constructorParamValues: unknown[],\n): Array<string | bigint | boolean> {\n  /**\n   * Internal Solidity type checklist\n   * 1. tuple, array -> JSON.parse | todo: Recursively parse the content\n   * 2. uint, int -> bigint\n   * 3. address -> string\n   * 4. string -> string\n   * 5. bytes, bytes32 etc. -> string\n   * 6. bool -> boolean\n   * >>> Make sure to return the original value at the end of the function <<<\n   */\n\n  // Make sure they have the same length\n  if (constructorParamTypes.length !== constructorParamValues.length) {\n    throw new Error(\n      `Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`,\n    );\n  }\n  return constructorParamTypes.map((type, index) => {\n    const value = constructorParamValues[index];\n    if (type === \"tuple\" || type.endsWith(\"]\")) {\n      if (typeof value === \"string\") {\n        return JSON.parse(value);\n      }\n      return value;\n    }\n    if (type === \"string\") {\n      return String(value);\n    }\n    if (type === \"bytes32\") {\n      if (!isHex(value)) {\n        throw new Error(`${value} is not a valid hex string`);\n      }\n      return padHex(value);\n    }\n    if (type.startsWith(\"bytes\")) {\n      if (!isHex(value)) {\n        throw new Error(`${value} is not a valid hex string`);\n      }\n      return value;\n    }\n    if (type === \"address\") {\n      if (typeof value !== \"string\" || !isAddress(value)) {\n        throw new Error(`${value} is not a valid address`);\n      }\n      return value;\n    }\n    if (type.startsWith(\"uint\") || type.startsWith(\"int\")) {\n      if (typeof value === \"bigint\") {\n        return value;\n      }\n      if (typeof value !== \"string\" && typeof value !== \"number\") {\n        throw new Error(`Cannot convert type ${typeof value} to BigInt`);\n      }\n      try {\n        const val = BigInt(value);\n        return val;\n      } catch (err) {\n        throw new Error((err as Error).message);\n      }\n    }\n    if (type.startsWith(\"bool\")) {\n      if (value === \"false\" || value === false) {\n        return false;\n      }\n      if (value === \"true\" || value === true) {\n        return true;\n      }\n      throw new Error(\n        \"Invalid boolean value. Expecting either 'true' or 'false'\",\n      );\n    }\n\n    // Return the value here if none of the types match\n    return value;\n  });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CM,SAAUA,MAAK,SAAqB;AACxC,MAAI,QAAQ;AAAM,WAAO,YAAY,OAAO;AAC5C,SAAO,WAAW,OAAO;AAC3B;AA4BM,SAAU,WAAW,SAA2B;AACpD,QAAMA,QAAa,QAAgBA,MAAK,QAAQ,IAAI,CAAC;AAErD,MAAI,QAAcC,YAAW,QAAQ,KAAK;AAC1C,MAAI,MAAM,CAAC,MAAM;AAAG,YAAQ,IAAI,WAAW,CAAA,CAAE;AAE7C,SAAeD,MACb,KAAUE,WAAc,UAAU,CAACF,OAAM,KAAK,GAAG,EAAE,IAAI,MAAK,CAAE,CAAC,EAAE,MAAM,EAAE,CAAC,EAAqB;AAEnG;AAqCM,SAAU,YAAY,SAA4B;AACtD,QAAMA,QAAa,QAAgBA,MAAK,QAAQ,IAAI,CAAC;AACrD,QAAM,OAAa,QACXG,UAAS,QAAQ,IAAI,IAAI,QAAQ,OAAa,QAAQ,QAAQ,IAAI,GACxE,EAAE;AAGJ,QAAM,gBAAgB,MAAK;AACzB,QAAI,kBAAkB,SAAS;AAC7B,UAAUA,UAAS,QAAQ,YAAY;AAAG,eAAO,QAAQ;AACzD,aAAa,QAAQ,QAAQ,YAAY;IAC3C;AACA,WAAYD,WAAU,QAAQ,UAAU,EAAE,IAAI,QAAO,CAAE;EACzD,GAAE;AAEF,SAAeF,MACT,MACGE,WACG,OAAa,QAAQ,MAAM,GAAGF,OAAM,MAAM,YAAY,GAC5D,EAAE,IAAI,MAAK,CAAE,GAEf,EAAE,CACH;AAEL;;;ACxIA,IAAM,qBAAqB,oBAAI,IAAG;AAmBlC,eAAsB,iBACpB,SAAgC;AAEhC,QAAM,UAAU,QAAQ,MAAM;AAE9B,MAAI,mBAAmB,IAAI,OAAO,GAAG;AACnC,WAAO,mBAAmB,IAAI,OAAO;EACvC;AACA,MAAI,SAAS;AACb,MAAI;AAKF,UAAM,aAAa,aAAa,OAAO;AACvC,UAAM,uBACJ,YACA,kVAAkV;EAGtV,SAAS,GAAQ;AACf,UAAM,WAAW,EAAE,SAAQ,EAAG,YAAW;AACzC,UAAM,YAAY,KAAK,UAAU,CAAC,EAAE,YAAW;AAE/C,QAAI,WAAW,QAAQ,KAAK,WAAW,SAAS,GAAG;AACjD,eAAS;IACX;EACF;AACA,qBAAmB,IAAI,SAAS,MAAM;AACtC,SAAO;AACT;AAEA,IAAM,6BAA6B;EACjC,CAAC,WAAW,WAAW;EACvB,CAAC,SAAS,SAAS;;AAErB,IAAM,mBAAmB;EACvB;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;AAGF,SAAS,WAAW,OAAa;AAC/B,QAAM,WAAW,iBAAiB,KAAK,CAAC,cACtC,MAAM,SAAS,SAAS,CAAC;AAG3B,MAAI,UAAU;AACZ,WAAO;EACT;AAGA,SAAO,2BAA2B,KAAK,CAAC,QAAO;AAC7C,QAAI,aAAa;AAEjB,eAAW,aAAa,KAAK;AAC3B,kCAAe,MAAM,SAAS,SAAS;IACzC;AACA,WAAO;EACT,CAAC;AACH;;;ACxEA,eAAsB,sBACpB,SAAqC;AAGrC,QAAM,OAAgBI,WACpB,qBAAqB,EAAE,aAAa,QAAQ,YAAW,CAAE,CAAC;AAG5D,QAAM,WAAW,MAAK;AACpB,QACE,aAAa,QAAQ,aACrB,OAAO,QAAQ,UAAU,YAAY,aACrC;AACA,aAAO,QAAQ,UAAU;IAC3B;AAEA,QACE,OAAO,QAAQ,aACf,OAAO,QAAQ,UAAU,MAAM,aAC/B;AACA,aAAqB,WAAW,OAAO,QAAQ,UAAU,CAAC,CAAC;IAC7D;AAEA,UAAM,IAAI,MACR,6EAA6E;EAEjF,GAAE;AAGF,QAAM,UAAU,MAAM,eAAe;IACnC;IACA,WAAyBC,OAAM;MAC7B,GAAW,SAAS,QAAQ,UAAU,CAAC;MACvC,GAAW,SAAS,QAAQ,UAAU,CAAC;MACvC;KACD;GACF;AAID,QAAM,cAAc,qBAAqB;IACvC,aAAa,QAAQ;IACrB,WAAW,QAAQ;GACpB;AAED,SAAO;IACL,eAAe;IACf;;AAEJ;;;ACtDA,IAAM,yBAAyB;AAK/B,IAAM,2BACJ;AAIF,IAAM,YAAY;EAChB,GAAG;EACH,GAAG;EACH,GAAG;;AAgBL,eAAsB,6BACpB,SAAuB;AAEvB,QAAM,UAAU,QAAQ,MAAM;AAE9B,SAAO,UACL,YAAW;AAtDf;AAuDM,QAAI,UAAU,QAAQ,SAAQ,CAAE,GAAG;AACjC,aAAO,UAAU,QAAQ,SAAQ,CAAE;IACrC;AAEA,QAAI,qBAAqB,OAAO,GAAG;AACjC,YAAMC,iBAAgB,MAAM,iBAAiB,OAAO;AACpD,YAAMC,YAAWD,iBAAgB,UAAU;AAC3C,YAAM,YAAW,0BAAqB,QAAQ,SAAQ,CAAE,MAAvC,mBAA0C;AAC3D,YAAM,YAAW,0BAAqB,QAAQ,SAAQ,CAAE,MAAvC,mBAA0C;AAE3D,YAAME,kBAAiB,MAAM,iCAC3BD,WACA;QACE;QACA;OACD;AAGH,aAAOC,gBAAe;IACxB;AAGA,UAAM,cAAc,MAAM,QAAQ,IAAI;;MAEpC,GAAG,gBAAgB,IAAI,CAAC,MAAK;AAC3B,eAAO,iCAAiC,SAAS,EAAE,UAAU,EAAC,CAAE;MAClE,CAAC;;MAGD,GAAG,gBAAgB,IAAI,CAAC,MAAK;AAC3B,eAAO,iCAAiC,GAAG,EAAE,UAAU,EAAC,CAAE;MAC5D,CAAC;KACF;AAED,UAAM,eAAe,MAAM,QAAQ,IACjC,YAAY,IAAI,CAAC,MAAK;AACpB,YAAM,cAAc,YAAY;QAC9B,GAAG;QACH,SAAS,EAAE;OACZ;AACD,aAAO,mBAAmB,WAAW;IACvC,CAAC,CAAC;AAGJ,UAAM,uBAAuB,YAAY,UACvC,CAAC,MAAM,EAAE,qBAAqB,sBAAsB;AAEtD,QAAI,wBAAwB,aAAa,oBAAoB,GAAG;AAC9D,aAAO;IACT;AAEA,UAAM,4BAA4B,aAAa,UAAU,CAAC,MAAM,CAAC;AACjE,QACE,6BACA,iBACA,iBAAY,yBAAyB,MAArC,mBAAwC,mBACxC;AAEA,cAAO,iBAAY,yBAAyB,MAArC,mBACH;IACN;AAEA,UAAM,CAAC,eAAe,eAAe,IAAI,MAAM,QAAQ,IAAI;MACzD,iBAAiB,OAAO;MACxB,YAAY,OAAO;KACpB;AACD,UAAM,WAAW,gBAAgB,UAAU;AAC3C,UAAM,MAAM,uBAAuB,eAAe;AAElD,UAAM,iBAAiB,MAAM,iCAAiC,UAAU;MACtE,UAAU;KACX;AAED,WAAO,eAAe;EACxB,GACA;IACE,UAAU,kBAAkB,OAAO;IACnC,WAAW,KAAK,KAAK,KAAK;;GAC3B;AAEL;AAKA,eAAsB,0BAA0B,SAAuB;AACrE,QAAM,UAAU,MAAM,6BAA6B,OAAO;AAC1D,QAAM,UAAU,YAAY;IAC1B,GAAG;IACH;GACD;AACD,QAAM,aAAa,MAAM,mBAAmB,OAAO;AACnD,MAAI,CAAC,YAAY;AACf,WAAO;EACT;AACA,SAAO;AACT;AAMA,eAAsB,qBAAqB,SAAiC;AA7J5E;AA8JE,QAAM,EAAE,QAAQ,OAAO,QAAO,IAAK;AACnC,QAAM,gBAAgB,MAAM,iBAAiB,OAAO;AACpD,QAAM,UAAU,QAAQ,MAAM;AAC9B,QAAM,WAAW,gBAAgB,UAAU;AAE3C,QAAM,aAAa,aAAa;IAC9B;IACA;GACD;AAED,MAAI;AACJ,MAAI;AAEJ,MAAI,qBAAqB,OAAO,GAAG;AACjC,gBAAW,0BAAqB,QAAQ,SAAQ,CAAE,MAAvC,mBAA0C;AACrD,gBAAW,0BAAqB,QAAQ,SAAQ,CAAE,MAAvC,mBAA0C;EACvD,OAAO;AACL,UAAM,kBAAkB,MAAM,YAAY,OAAO;AACjD,eAAW,uBAAuB,eAAe;EACnD;AAEA,QAAM,iBAAiB,MAAM,iCAAiC,UAAU;IACtE;IACA;GACD;AAED,QAAM,UAAU,MAAM,eAAe,YAAY;IAC/C,SAAS,eAAe;GACzB;AAED,MAAI,UAAU,eAAe,aAAa;AACxC,UAAM,cAAc,mBAAmB;MACrC;MACA;MACA,IAAI,eAAe;MACnB,OAAO,eAAe;KACvB;AACD,UAAM,MAAM,MAAM,gBAAgB,EAAE,aAAa,QAAO,CAAE;AAC1D,UAAM,eAAe,GAAG;EAC1B;AACA,QAAM,kBAAkB,MAAM,uBAC5B,YACA,eAAe,WAAW;AAE5B,SAAO;IACL;;AAEJ;AASA,eAAe,iCACb,SACA,YAAoD;AAIpD,QAAM,WAAW,WAAW,WAAW,WAAW,WAAW,OAAO,OAAO;AAC3E,QAAM,MAAM,WAAW,WAAW,WAAW,WAAW;AACxD,QAAM,wBAAwB,MAAM,sBAAsB;IACxD,aAAa;MACX;MACA;MACA,OAAO;MACP,MAAM;MACN,SAAS,YAAY,IAAI,OAAO,OAAO,IAAI;;IAE7C,WAAW;GACZ;AACD,QAAM,wBAA4CC,MAAK;IACrD,MAAM,sBAAsB;IAC5B,OAAO;GACR;AAED,SAAO;IACL,GAAG;IACH,aAAa,WAAW;IACxB,kBAAkB,WAAW,qBAAqB;;AAEtD;AAEA,SAAS,uBAAuB,UAAgB;AAC9C,SAAO,gBAAgB,KAAK,CAAC,MAAM,KAAK,QAAQ,KAAK;AACvD;AASA,IAAM,uBAAoD;EACxD,QAAQ;IACN,MAAM;IACN,UAAU;;EAEZ,SAAS;IACP,MAAM;IACN,UAAU,SAAS,OAAO;;EAE5B,cAAc;IACZ,MAAM;IACN,UAAU;;EAEZ,OAAO;IACL,MAAM;IACN,UAAU,QAAQ,OAAO;;EAE3B,OAAO;IACL,MAAM;IACN,UAAU,QAAQ,OAAO;;EAE3B,QAAQ;IACN,MAAM;IACN,UAAU,QAAQ,OAAO;;EAE3B,QAAQ;IACN,MAAM;IACN,UAAU,QAAQ,OAAO;;EAE3B,OAAO;IACL,MAAM;IACN,UAAU,QAAQ,OAAO;;EAE3B,OAAO;IACL,MAAM;IACN,UAAU,UAAU,OAAO;;EAE7B,SAAS;IACP,MAAM;IACN,UAAU,QAAQ,OAAO;IACzB,UAAU;;EAEZ,SAAS;IACP,MAAM;IACN,UAAU,QAAQ,OAAO;IACzB,UAAU;;;EAGZ,cAAc;IACZ,MAAM;IACN,UAAU;;EAEZ,cAAc;IACZ,MAAM;IACN,UAAU;;EAEZ,cAAc;IACZ,MAAM;IACN,UAAU;;EAEZ,cAAc;IACZ,MAAM;IACN,UAAU;;;AAId,IAAM,YAAoC;EACxC,aAAa;EACb,aAAa;EACb,SAAS;;;AAGX,IAAM,kBAAkB;EACtB;EACA,KAAK,OAAO;EACZ,OAAO,OAAO;EACd,OAAO,OAAO;EACd,QAAQ,OAAO;EACf,QAAQ,OAAO;EACf,QAAQ,OAAO;EACf,QAAQ,OAAO;EACf,SAAU,OAAO;EACjB,SAAU,OAAO;EACjB,SAAU,OAAO;EACjB,SAAU,OAAO;EACjB,UAAW,OAAO;EAClB,UAAW,OAAO;EAClB,UAAW,OAAO;EAClB,UAAW,OAAO;EAClB,WAAa,OAAO;;;;ACzUhB,SAAU,SAAS,OAAa;AACpC,SAAO,UAAU,cAAc,KAAK,CAAC;AACvC;;;ACDM,SAAU,YAAY,UAAgB;AAC1C,QAAM,eAAe,SAAS,qBAAqB,QAAQ,CAAC;AAC5D,QAAM,OAAO,MAAM,YAAY;AAC/B,SAAO,SAAS,IAAI;AACtB;;;ACYM,SAAU,yBACd,SAAwC;AAExC,QAAM,WAAW,qBAAqB,QAAQ,QAAQ;AACtD,QAAM,WAAW,QAAQ,OACrB,MAAM,QAAQ,IAAI,KAAK,QAAQ,KAAK,WAAW,KAC7C,QAAQ,OACR,SAAS,QAAQ,IAAI,IACvB,YAAY,QAAQ;AAGxB,QAAM,eAAe,QAAQ,mBACzB,aACE,CAAC,SAAS,SAAS,OAAO,GAC1B,CAAC,UAAU,QAAQ,aAAa,QAAQ,gBAAgB,CAAC,IAE3D,aAAa,CAAC,SAAS,OAAO,GAAG,CAAC,UAAU,QAAQ,WAAW,CAAC;AAGpE,QAAM,mBAAmB,aACvB,CAAC,UAAU,WAAW,WAAW,SAAS,GAC1C;IACE;IACA,WAAW,QAAQ,qBAAqB;IACxC;IACA,UAAU,aAAa,CAAC,OAAO,GAAG,CAAC,YAAY,CAAC,CAAC;GAClD;AAIH,QAAM,mBAAmB,UACvB,aAAa,CAAC,OAAO,GAAG,CAAC,gBAAgB,CAAC,CAAC;AAI7C,SAAO,KAAK,iBAAiB,MAAM,EAAE,CAAC;AACxC;;;ACzCM,SAAU,wBACd,SAAwC;AAExC,QAAM,WAAW,qBAAqB,QAAQ,QAAQ;AAEtD,QAAM,WAAW,QAAQ,OACrB,MAAM,QAAQ,IAAI,KAAK,QAAQ,KAAK,WAAW,KAC7C,QAAQ,OACR,SAAS,QAAQ,IAAI,IACvB,YAAY,QAAQ;AAExB,QAAM,cACJ,OAAO,QAAQ,gBAAgB,WAC3B,QAAQ,cACR,gBAAgB,QAAQ,WAAW;AAEzC,SAAO,aACL,CAAC,WAAW,SAAS,OAAO,GAC5B,CAAC,UAAU,UAAU,WAAW,CAAC;AAErC;;;AC/CA,IAAM,iBAAiB,oBAAI,IAAG;AAC9B,IAAM,cAAc,oBAAI,IAAG;AAM3B,IAAM,gBAAgB;AAEtB,eAAe,yBACb,QAAc;AAEd,MAAI,eAAe,IAAI,MAAM,GAAG;AAC9B,WAAO,eAAe,IAAI,MAAM;EAClC;AACA,QAAM,MAAM,MAAM,MAChB,GAAG,aAAa,0CAA0C,MAAM,EAAE;AAEpE,MAAI,CAAC,IAAI,IAAI;AACX,WAAO;EACT;AACA,QAAM,OAAO,MAAM,IAAI,KAAI;AAC3B,MAAI,KAAK,UAAU,GAAG;AACpB,WAAO;EACT;AACA,QAAM,YAAY,YAAY,KAAK,QAAQ,CAAC,EAAE,cAAc;AAC5D,iBAAe,IAAI,QAAQ,SAAS;AACpC,SAAO;AACT;AAEA,eAAe,sBACb,QAAc;AAEd,MAAI,YAAY,IAAI,MAAM,GAAG;AAC3B,WAAO,YAAY,IAAI,MAAM;EAC/B;AACA,QAAM,MAAM,MAAM,MAChB,GAAG,aAAa,gDAAgD,MAAM,EAAE;AAE1E,MAAI,CAAC,IAAI,IAAI;AACX,WAAO;EACT;AACA,QAAM,OAAO,MAAM,IAAI,KAAI;AAC3B,MAAI,KAAK,UAAU,GAAG;AACpB,WAAO;EACT;AAEA,QAAM,YAAY,SAAS,qBACzB,KAAK,QAAQ,CAAC,EAAE,cAAc,CAC/B;AACD,cAAY,IAAI,QAAQ,SAAS;AACjC,SAAO;AACT;AAEA,SAAS,qBAAqB,KAAW;AACvC,SAAO,IAAI,OAAO,CAAC,EAAE,YAAW,IAAK,IAAI,MAAM,CAAC;AAClD;AAcA,eAAsB,iBAAiB,QAAc;AAInD,MAAI,OAAO,WAAW,IAAI,GAAG;AAE3B,aAAS,OAAO,MAAM,CAAC;EACzB;AACA,QAAM,MAAM,MAAM,QAAQ,IAAI;IAC5B,yBAAyB,MAAM;IAC/B,sBAAsB,MAAM;GAC7B;AACD,SAAO;IACL,UAAU,IAAI,CAAC;IACf,OAAO,IAAI,CAAC;;AAEhB;AAcA,eAAsB,kBAAkB,SAAiB;AAMvD,YAAU,MAAM,KAAK,IAAI,IAAI,OAAO,CAAC;AACrC,QAAM,MAAM,MAAM,QAAQ,IACxB,QAAQ,IAAI,CAAC,WAAW,iBAAiB,MAAM,CAAC,CAAC;AAEnD,SAAO;IACL,WAAW,IACR,IAAI,CAAC,MAAM,EAAE,QAAQ,EACrB,OAAO,CAAC,MAAM,MAAM,IAAI,EACxB,KAAI;IACP,QAAQ,IACL,IAAI,CAAC,MAAM,EAAE,KAAK,EAClB,OAAO,CAAC,MAAM,MAAM,IAAI,EACxB,KAAI;;AAEX;;;AC3FM,SAAUC,MAAK,EAAE,MAAM,WAAU,GAAe;AACpD,QAAM,EAAE,GAAG,GAAG,QAAO,IAAmB,KAAK,EAAE,SAAS,MAAM,WAAU,CAAE;AAC1E,SAAO;IACL,GAAG,MAAM,GAAG,EAAE,MAAM,GAAE,CAAE;IACxB,GAAG,MAAM,GAAG,EAAE,MAAM,GAAE,CAAE;IACxB,GAAG,YAAY,IAAI,MAAM;IACzB;;AAEJ;;;ACVM,SAAU,eAAe,WAK9B;AACC,QAAM,EAAE,GAAG,GAAG,GAAG,QAAO,IAAK;AAC7B,SAAqBC,OACL,KACZ,OAAO,YAAY,cACf;IACE;IACA;IACA,SAAS,CAAS,SAAS,OAAO,IACtB,WAAW,OAAO,IAC1B;MAEN;IACE;IACA;IACA,GACE,CAAS,SAAS,CAAC,KAAK,OAAO,MAAM,cACzB,WAAW,CAAC,IACpB;GACP,CACN;AAEL;;;AC6FM,SAAUC,QACd,UACA,MACA,UAA0B,CAAA,GAAE;AAE5B,MAAQ,KAAK,IAAI,IAAI;AAAG,UAAM,IAAY,yBAAyB,EAAE,KAAI,CAAE;AAC3E,MAAI,SAAS,OAAO,WAAW;AAAG,WAAO;AAEzC,QAAM,SAAuB,OAC3B,SAAS,QACL,MAAM,MAAM,CAAC,GACjB,OAAO;AAET,MAAI,UAAU,OAAO,KAAK,MAAM,EAAE,WAAW,GAAG;AAC9C,QAAI,MAAM,QAAQ,MAAM;AAAG,aAAO,OAAO,CAAC;AAC1C,WAAO,OAAO,OAAO,MAAM,EAAE,CAAC;EAChC;AACA,SAAO;AACT;AAgQM,SAAUC,MAGd,UAQA,UAAwB,CAAA,GAAE;AAE1B,SAAeA,MAAK,UAAsB,OAAO;AACnD;AAmFM,SAAUC,SASd,KACA,MACA,SAKC;AAED,MAAI,SAAS;AAAS,WAAO;AAC7B,MAAI,SAAS;AAAS,WAAO;AAC7B,MAAQ,SAAS,MAAM,EAAE,QAAQ,MAAK,CAAE,GAAG;AACzC,UAAM,WAAe,MAAM,MAAM,GAAG,CAAC;AACrC,QAAI,aAAa;AAAuB,aAAO;AAC/C,QAAI,aAAa;AAAuB,aAAO;EACjD;AAEA,QAAM,OAAe,QAAQ,KAAK,MAAM,OAAc;AACtD,MAAI,KAAK,SAAS;AAChB,UAAM,IAAY,cAAc,EAAE,MAAM,MAAM,QAAO,CAAE;AACzD,SAAO;AACT;AA0EO,IAAM,gBAA8BC,MAAK;EAC9C,QAAQ;IACN;MACE,MAAM;MACN,MAAM;;;EAGV,MAAM;EACN,MAAM;CACP;AAEM,IAAM,wBAAwB;AAE9B,IAAM,gBAA8BA,MAAK;EAC9C,QAAQ;IACN;MACE,MAAM;MACN,MAAM;;;EAGV,MAAM;EACN,MAAM;CACP;AAEM,IAAM,wBAAwB;;;AClnBrC,eAAsB,YAAqC,SAG1D;AACC,QAAM,EAAE,UAAU,KAAI,IAAK;AAC3B,MAAI,MAAM,qCAAU;AACpB,MAAI,YAAY,CAAC,KAAK;AACpB,UAAM,MAAM,mBAAmB,QAAQ,EAAE,MAAM,MAAM,MAAS;EAChE;AACA,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MACR,6BAA6B,SAAS,OAAO,aAAa,SAAS,MAAM,EAAE,EAAE;EAEjF;AACA,QAAM,WAAwBC,SAAQ,KAAK,IAAI;AAC/C,SAAoBC,QAAO,UAAU,IAAI;AAC3C;;;AChBA,eAAsB,mBAA4C,SAGjE;AACC,QAAM,EAAE,UAAU,KAAI,IAAK;AAC3B,MAAI,MAAM,qCAAU;AACpB,MAAI,YAAY,CAAC,KAAK;AACpB,UAAM,MAAM,mBAAmB,QAAQ,EAAE,MAAM,MAAM,MAAS;EAChE;AACA,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MACR,6BAA6B,SAAS,OAAO,aAAa,SAAS,MAAM,EAAE,EAAE;EAEjF;AACA,QAAM,cAA8BC,SAAQ,KAAK,IAAI;AACrD,SAAuB,WAAW,aAAa,IAAI;AACrD;;;AChBA,eAAsB,qBAA8C,SAGnE;AACC,QAAM,EAAE,UAAU,GAAG,KAAI,IAAK;AAC9B,MAAI,MAAM,qCAAU;AACpB,MAAI,YAAY,CAAC,KAAK;AACpB,UAAM,MAAM,mBAAmB,QAAQ,EAAE,MAAM,MAAM,MAAS;EAChE;AACA,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MACR,6BAA6B,SAAS,OAAO,aAAa,SAAS,MAAM,EAAE,EAAE;EAEjF;AACA,QAAM,cAA8BC,SAAQ,KAAK,KAAK,IAAI;AAC1D,SAAuB,aAAa,aAAa,KAAK,IAAI;AAC5D;;;AC5BO,IAAM,qCACX;;;ACSI,SAAU,UAAU,KAAW;AACnC,QAAM,CAAC,eAAe,gBAAgB,gBAAgB,IAAI,IAAI,MAAM,GAAG;AAEvE,MAAI,kBAAkB,oCAAoC;AACxD,UAAM,IAAI,MAAM,oBAAoB;EACtC;AACA,MAAI,CAAC,kBAAkB,CAAC,kBAAkB;AACxC,UAAM,IAAI,MAAM,aAAa;EAC/B;AAEA,QAAM,UAAsB,KAAK,MAAM,eAAe,cAAc,CAAC;AACrE,QAAM,YAAY,eAAe,gBAAgB;AAEjD,SAAO;IACL;IACA;;AAEJ;;;ACaA,eAAsB,UAAU,SAAwB;AACtD,QAAM,UAAU,MAAM,iBAAiB,QAAQ,OAAO;AACtD,QAAM,UAAU,UAAU,OAAO;AAEjC,QAAM,YAAY,MAAM,QAAQ,QAAQ,YAAY,EAAE,QAAO,CAAE;AAE/D,QAAM,cAAc,mBAAmB,cAAc,OAAO,GAAG;IAC7D,SAAS;GACV;AAED,QAAM,mBAAmB,mBAAmB,cAAc,SAAS,GAAG;IACpE,SAAS;GACV;AAGD,SAAO,GAAG,kCAAkC,IAAI,WAAW,IAAI,gBAAgB;AACjF;AAEA,eAAe,iBAAiB,SAAwB;AACtD,SAAO;IACL,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,QAAQ;IACb,KAAK,KAAK,MAAM,QAAQ,IAAI,QAAO,IAAK,GAAI;IAC5C,KAAK,KAAK,MAAM,QAAQ,IAAI,QAAO,IAAK,GAAI;IAC5C,KAAK,KAAK,MAAM,QAAQ,IAAI,QAAO,IAAK,GAAI;;IAE5C,KAAK,QAAQ,OAAQ,MAAM,eAAc;IACzC,KAAK,QAAQ;;AAEjB;;;AC1EA,IAAM,0BAA0B,KAAK,KAAK;AAwB1C,eAAsB,WAAW,SAAyB;AACxD,QAAM,EAAE,SAAS,KAAK,iBAAiB,wBAAuB,IAAK;AACnE,QAAM,UAAU,UAAU,GAAG,EAAE;AAC/B,SAAO,UAAU;IACf,SAAS;MACP,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,QAAQ;MACb,KAAK,oBAAI,KAAI;MACb,KAAK,IAAI,KAAK,KAAK,IAAG,IAAK,cAAc;MACzC,KAAK,oBAAI,KAAI;MACb,KAAK,QAAQ;;IAEf;GACD;AACH;;;ACbM,SAAU,eACd,uBACA,wBAAiC;AAcjC,MAAI,sBAAsB,WAAW,uBAAuB,QAAQ;AAClE,UAAM,IAAI,MACR,qDAAqD,uBAAuB,MAAM,cAAc,sBAAsB,MAAM,EAAE;EAElI;AACA,SAAO,sBAAsB,IAAI,CAAC,MAAM,UAAS;AAC/C,UAAM,QAAQ,uBAAuB,KAAK;AAC1C,QAAI,SAAS,WAAW,KAAK,SAAS,GAAG,GAAG;AAC1C,UAAI,OAAO,UAAU,UAAU;AAC7B,eAAO,KAAK,MAAM,KAAK;MACzB;AACA,aAAO;IACT;AACA,QAAI,SAAS,UAAU;AACrB,aAAO,OAAO,KAAK;IACrB;AACA,QAAI,SAAS,WAAW;AACtB,UAAI,CAAC,MAAM,KAAK,GAAG;AACjB,cAAM,IAAI,MAAM,GAAG,KAAK,4BAA4B;MACtD;AACA,aAAO,OAAO,KAAK;IACrB;AACA,QAAI,KAAK,WAAW,OAAO,GAAG;AAC5B,UAAI,CAAC,MAAM,KAAK,GAAG;AACjB,cAAM,IAAI,MAAM,GAAG,KAAK,4BAA4B;MACtD;AACA,aAAO;IACT;AACA,QAAI,SAAS,WAAW;AACtB,UAAI,OAAO,UAAU,YAAY,CAAC,UAAU,KAAK,GAAG;AAClD,cAAM,IAAI,MAAM,GAAG,KAAK,yBAAyB;MACnD;AACA,aAAO;IACT;AACA,QAAI,KAAK,WAAW,MAAM,KAAK,KAAK,WAAW,KAAK,GAAG;AACrD,UAAI,OAAO,UAAU,UAAU;AAC7B,eAAO;MACT;AACA,UAAI,OAAO,UAAU,YAAY,OAAO,UAAU,UAAU;AAC1D,cAAM,IAAI,MAAM,uBAAuB,OAAO,KAAK,YAAY;MACjE;AACA,UAAI;AACF,cAAM,MAAM,OAAO,KAAK;AACxB,eAAO;MACT,SAAS,KAAK;AACZ,cAAM,IAAI,MAAO,IAAc,OAAO;MACxC;IACF;AACA,QAAI,KAAK,WAAW,MAAM,GAAG;AAC3B,UAAI,UAAU,WAAW,UAAU,OAAO;AACxC,eAAO;MACT;AACA,UAAI,UAAU,UAAU,UAAU,MAAM;AACtC,eAAO;MACT;AACA,YAAM,IAAI,MACR,2DAA2D;IAE/D;AAGA,WAAO;EACT,CAAC;AACH;",
  "names": ["from", "fromNumber", "keccak256", "validate", "keccak256", "toHex", "enforceEip155", "eipChain", "deploymentInfo", "from", "sign", "toHex", "decode", "from", "fromAbi", "from", "fromAbi", "decode", "fromAbi", "fromAbi"]
}
