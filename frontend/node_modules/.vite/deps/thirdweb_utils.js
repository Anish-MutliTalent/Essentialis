import {
  getClaimParams
} from "./chunk-FFQVPDE3.js";
import {
  extractMinimalProxyImplementationAddress,
  resolveImplementation
} from "./chunk-G6JRA4F5.js";
import {
  ensureBytecodePrefix,
  extractIPFSUri
} from "./chunk-BYBTELOG.js";
import {
  signMessage,
  signTypedData
} from "./chunk-ZSBKCZVH.js";
import {
  sha256
} from "./chunk-6IKSF6CX.js";
import "./chunk-U4HHAIE3.js";
import {
  sign
} from "./chunk-2JMEOC4X.js";
import {
  InvalidSelectorSizeError,
  NotFoundError,
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  decodeData,
  decodeResult,
  from as from3,
  fromAbi,
  fromAbi2,
  fromBytes as fromBytes2,
  hashMessage
} from "./chunk-5T45IMNW.js";
import {
  fromBytes,
  serializeTransaction
} from "./chunk-YNTQV2T3.js";
import {
  from,
  toHex as toHex2,
  vToYParity
} from "./chunk-5DLV5WR6.js";
import "./chunk-GSVLZU3T.js";
import {
  formatNumber,
  isValidENSName,
  shortenLargeNumber
} from "./chunk-VFOFSQSA.js";
import "./chunk-SZAERADR.js";
import "./chunk-Y6OHVLDO.js";
import {
  base64ToString,
  uint8ArrayToBase64
} from "./chunk-CA2EJBUN.js";
import {
  max,
  min
} from "./chunk-HL4VUZA4.js";
import {
  waitForReceipt
} from "./chunk-DEON3F34.js";
import "./chunk-QWTK625L.js";
import {
  eth_getBalance
} from "./chunk-BKSLBPLK.js";
import "./chunk-YCZ3YGMG.js";
import {
  clearTransactionDecorator,
  getTransactionDecorator,
  sendTransaction,
  setTransactionDecorator
} from "./chunk-32UNHBSF.js";
import "./chunk-YQXA2AWL.js";
import {
  decode
} from "./chunk-RLZQZOTA.js";
import {
  isContractDeployed
} from "./chunk-WQM2SOQQ.js";
import {
  from as from2,
  keccak256 as keccak2562
} from "./chunk-CQABUGWC.js";
import "./chunk-PHFEZCFB.js";
import {
  maxUint256
} from "./chunk-V4DR3IRU.js";
import "./chunk-SWAFX6ND.js";
import {
  prepareTransaction
} from "./chunk-QGXAPRFG.js";
import "./chunk-SLZ3Y5V2.js";
import {
  detectMethod
} from "./chunk-RNESBU4Y.js";
import "./chunk-DABXKW5Y.js";
import {
  encodeAbiParameters
} from "./chunk-C3UIV4TQ.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import "./chunk-5LTEBNG6.js";
import {
  isZkSyncChain
} from "./chunk-BIVYGU57.js";
import {
  getGasPrice,
  resolveContractAbi,
  resolvePromisedValue
} from "./chunk-6AN5T5RL.js";
import "./chunk-MH6B2CTO.js";
import {
  fromGwei,
  toEther,
  toTokens,
  toUnits,
  toWei
} from "./chunk-HAADYJEF.js";
import {
  concatHex
} from "./chunk-C67JNMHT.js";
import "./chunk-DV4XGEHR.js";
import {
  encodePacked,
  isBytes,
  recoverAddress
} from "./chunk-GRBRMOVF.js";
import {
  getContract
} from "./chunk-6K2H5JDO.js";
import {
  checksumAddress,
  getAddress,
  isAddress,
  keccak256,
  shortenAddress,
  shortenHex
} from "./chunk-VNYBYIMU.js";
import {
  boolToBytes,
  hexToBytes,
  numberToBytes,
  stringToBytes,
  toBytes
} from "./chunk-OKXYG5CJ.js";
import "./chunk-LC6YL3ZA.js";
import {
  randomBytesHex
} from "./chunk-CMZAKTPA.js";
import {
  getRpcClient
} from "./chunk-UOGLDG6G.js";
import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  boolToHex,
  fromHex as fromHex2,
  hexToBigInt,
  hexToBool,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isHex,
  numberToHex,
  padHex,
  stringToHex,
  toHex,
  uint8ArrayToHex
} from "./chunk-T7F22WNJ.js";
import {
  concat2 as concat,
  fromHex,
  fromNumber,
  fromNumber2,
  padLeft2 as padLeft,
  size,
  slice,
  toBigInt,
  validate,
  validate2
} from "./chunk-I364SXDL.js";
import "./chunk-VDSMUIMW.js";
import {
  decodeAbiParameters,
  toEventSelector,
  toFunctionSelector
} from "./chunk-HQ2F3JJN.js";
import "./chunk-QKQAKKUJ.js";
import "./chunk-HQXXW4RM.js";
import {
  withCache
} from "./chunk-MTFDOOBS.js";
import "./chunk-5V4VPUUX.js";
import "./chunk-PPP72TBL.js";
import "./chunk-3OXDSLPJ.js";
import {
  setServiceKey,
  setThirdwebDomains
} from "./chunk-5UJ7PIRT.js";
import "./chunk-256EKJAK.js";

// node_modules/ox/_esm/core/ContractAddress.js
function from4(options) {
  if (options.salt)
    return fromCreate2(options);
  return fromCreate(options);
}
function fromCreate(options) {
  const from6 = fromHex(from2(options.from));
  let nonce = fromNumber2(options.nonce);
  if (nonce[0] === 0)
    nonce = new Uint8Array([]);
  return from2(`0x${keccak2562(fromBytes([from6, nonce], { as: "Hex" })).slice(26)}`);
}
function fromCreate2(options) {
  const from6 = fromHex(from2(options.from));
  const salt = padLeft(validate2(options.salt) ? options.salt : fromHex(options.salt), 32);
  const bytecodeHash = (() => {
    if ("bytecodeHash" in options) {
      if (validate2(options.bytecodeHash))
        return options.bytecodeHash;
      return fromHex(options.bytecodeHash);
    }
    return keccak2562(options.bytecode, { as: "Bytes" });
  })();
  return from2(slice(keccak2562(concat(fromHex("0xff"), from6, salt, bytecodeHash), { as: "Hex" }), 12));
}

// node_modules/thirdweb/dist/esm/utils/any-evm/is-eip155-enforced.js
var EIP_ENFORCED_CACHE = /* @__PURE__ */ new Map();
async function isEIP155Enforced(options) {
  const chainId = options.chain.id;
  if (EIP_ENFORCED_CACHE.has(chainId)) {
    return EIP_ENFORCED_CACHE.get(chainId);
  }
  let result = false;
  try {
    const rpcRequest = getRpcClient(options);
    await eth_sendRawTransaction(rpcRequest, "0xf8a58085174876e800830186a08080b853604580600e600039806000f350fe7fffffffffffffffafffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf31ba02222222222222222222222222222222222222222222222222222222222222222a02222222222222222222222222222222222222222222222222222222222222222");
  } catch (e) {
    const errorMsg = e.toString().toLowerCase();
    const errorJson = JSON.stringify(e).toLowerCase();
    if (matchError(errorMsg) || matchError(errorJson)) {
      result = true;
    }
  }
  EIP_ENFORCED_CACHE.set(chainId, result);
  return result;
}
var ERROR_SUBSTRINGS_COMPOSITE = [
  ["account", "not found"],
  ["wrong", "chainid"]
];
var ERROR_SUBSTRINGS = [
  "eip-155",
  "eip155",
  "protected",
  "invalid chain id for signer",
  "chain id none",
  "chain_id mismatch",
  "recovered sender mismatch",
  "transaction hash mismatch",
  "chainid no support",
  "chainid (0)",
  "chainid(0)",
  "invalid sender"
];
function matchError(error) {
  const hasError = ERROR_SUBSTRINGS.some((substring) => error.includes(substring));
  if (hasError) {
    return true;
  }
  return ERROR_SUBSTRINGS_COMPOSITE.some((arr) => {
    let foundError = true;
    for (const substring of arr) {
      foundError && (foundError = error.includes(substring));
    }
    return foundError;
  });
}

// node_modules/thirdweb/dist/esm/utils/any-evm/keyless-transaction.js
async function getKeylessTransaction(options) {
  const hash = keccak2562(serializeTransaction({ transaction: options.transaction }));
  const yParity = (() => {
    if ("yParity" in options.signature && typeof options.signature.yParity !== "undefined") {
      return options.signature.yParity;
    }
    if ("v" in options.signature && typeof options.signature.v !== "undefined") {
      return vToYParity(Number(options.signature.v));
    }
    throw new Error("Invalid recovered signature provided with transaction, missing v or yParity");
  })();
  const address = await recoverAddress({
    hash,
    signature: toHex2({
      r: toBigInt(options.signature.r),
      s: toBigInt(options.signature.s),
      yParity
    })
  });
  const transaction = serializeTransaction({
    transaction: options.transaction,
    signature: options.signature
  });
  return {
    signerAddress: address,
    transaction
  };
}

// node_modules/thirdweb/dist/esm/contract/deployment/utils/create-2-factory.js
var COMMON_FACTORY_ADDRESS = "0x4e59b44847b379578588920cA78FbF26c0B4956C";
var CREATE2_FACTORY_BYTECODE = "0x604580600e600039806000f350fe7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe03601600081602082378035828234f58015156039578182fd5b8082525050506014600cf3";
var SIGNATURE = {
  v: 27n,
  r: "0x2222222222222222222222222222222222222222222222222222222222222222",
  s: "0x2222222222222222222222222222222222222222222222222222222222222222"
};
async function computeCreate2FactoryAddress(options) {
  const chainId = options.chain.id;
  return withCache(async () => {
    var _a, _b, _c, _d;
    if (FACTORIES[chainId.toString()]) {
      return FACTORIES[chainId.toString()];
    }
    if (CUSTOM_GAS_FOR_CHAIN[chainId]) {
      const enforceEip1552 = await isEIP155Enforced(options);
      const eipChain2 = enforceEip1552 ? chainId : 0;
      const gasPrice = (_a = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]) == null ? void 0 : _a.gasPrice;
      const gasLimit = (_b = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]) == null ? void 0 : _b.gasLimit;
      const deploymentInfo2 = await _getCreate2FactoryDeploymentInfo(eipChain2, {
        gasPrice,
        gasLimit
      });
      return deploymentInfo2.predictedAddress;
    }
    const allBinsInfo = await Promise.all([
      // to generate EIP-155 transaction
      ...CUSTOM_GAS_BINS.map((b) => {
        return _getCreate2FactoryDeploymentInfo(chainId, { gasPrice: b });
      }),
      // to generate pre EIP-155 transaction, hence chainId 0
      ...CUSTOM_GAS_BINS.map((b) => {
        return _getCreate2FactoryDeploymentInfo(0, { gasPrice: b });
      })
    ]);
    const allFactories = await Promise.all(allBinsInfo.map((b) => {
      const tempFactory = getContract({
        ...options,
        address: b.predictedAddress
      });
      return isContractDeployed(tempFactory);
    }));
    const indexOfCommonFactory = allBinsInfo.findIndex((b) => b.predictedAddress === COMMON_FACTORY_ADDRESS);
    if (indexOfCommonFactory && allFactories[indexOfCommonFactory]) {
      return COMMON_FACTORY_ADDRESS;
    }
    const indexOfExistingDeployment = allFactories.findIndex((b) => b);
    if (indexOfExistingDeployment && allBinsInfo && ((_c = allBinsInfo[indexOfExistingDeployment]) == null ? void 0 : _c.predictedAddress)) {
      return (_d = allBinsInfo[indexOfExistingDeployment]) == null ? void 0 : _d.predictedAddress;
    }
    const [enforceEip155, gasPriceFetched] = await Promise.all([
      isEIP155Enforced(options),
      getGasPrice(options)
    ]);
    const eipChain = enforceEip155 ? chainId : 0;
    const bin = _getNearestGasPriceBin(gasPriceFetched);
    const deploymentInfo = await _getCreate2FactoryDeploymentInfo(eipChain, {
      gasPrice: bin
    });
    return deploymentInfo.predictedAddress;
  }, {
    cacheKey: `create2factory:${chainId}`,
    cacheTime: 24 * 60 * 60 * 1e3
    // 1 day
  });
}
async function getDeployedCreate2Factory(options) {
  const address = await computeCreate2FactoryAddress(options);
  const factory = getContract({
    ...options,
    address
  });
  const isDeployed = await isContractDeployed(factory);
  if (!isDeployed) {
    return null;
  }
  return factory;
}
async function deployCreate2Factory(options) {
  var _a, _b;
  const { client, chain, account } = options;
  const enforceEip155 = await isEIP155Enforced(options);
  const chainId = options.chain.id;
  const eipChain = enforceEip155 ? chainId : 0;
  const rpcRequest = getRpcClient({
    client,
    chain
  });
  let gasPrice;
  let gasLimit;
  if (CUSTOM_GAS_FOR_CHAIN[chainId]) {
    gasPrice = (_a = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]) == null ? void 0 : _a.gasPrice;
    gasLimit = (_b = CUSTOM_GAS_FOR_CHAIN[chainId.toString()]) == null ? void 0 : _b.gasLimit;
  } else {
    const gasPriceFetched = await getGasPrice(options);
    gasPrice = _getNearestGasPriceBin(gasPriceFetched);
  }
  const deploymentInfo = await _getCreate2FactoryDeploymentInfo(eipChain, {
    gasPrice,
    gasLimit
  });
  const balance = await eth_getBalance(rpcRequest, {
    address: deploymentInfo.signerAddress
  });
  if (balance < deploymentInfo.valueToSend) {
    const transaction = prepareTransaction({
      chain,
      client,
      to: deploymentInfo.signerAddress,
      value: deploymentInfo.valueToSend
    });
    const res = await sendTransaction({ transaction, account });
    await waitForReceipt(res);
  }
  const transactionHash = await eth_sendRawTransaction(rpcRequest, deploymentInfo.transaction);
  return {
    transactionHash
  };
}
async function _getCreate2FactoryDeploymentInfo(chainId, gasOptions) {
  const gasPrice = gasOptions.gasPrice ? gasOptions.gasPrice : 100n * 10n ** 9n;
  const gas = gasOptions.gasLimit ? gasOptions.gasLimit : 100000n;
  const deploymentTransaction = await getKeylessTransaction({
    transaction: {
      gasPrice,
      gas,
      nonce: 0,
      data: CREATE2_FACTORY_BYTECODE,
      chainId: chainId !== 0 ? Number(chainId) : void 0
    },
    signature: SIGNATURE
  });
  const create2FactoryAddress = from4({
    from: deploymentTransaction.signerAddress,
    nonce: 0n
  });
  return {
    ...deploymentTransaction,
    valueToSend: gasPrice * gas,
    predictedAddress: getAddress(create2FactoryAddress)
  };
}
function _getNearestGasPriceBin(gasPrice) {
  return CUSTOM_GAS_BINS.find((e) => e >= gasPrice) || gasPrice;
}
var CUSTOM_GAS_FOR_CHAIN = {
  "5001": {
    name: "Mantle Testnet",
    gasPrice: 1n
  },
  "71402": {
    name: "Godwoken Mainnet",
    gasPrice: 40000n * 10n ** 9n
  },
  "1351057110": {
    name: "Chaos (SKALE Testnet)",
    gasPrice: 100000n
  },
  "361": {
    name: "Theta Mainnet",
    gasPrice: 4000n * 10n ** 9n
  },
  "365": {
    name: "Theta Testnet",
    gasPrice: 4000n * 10n ** 9n
  },
  "7700": {
    name: "Canto",
    gasPrice: 1000n * 10n ** 9n
  },
  "7701": {
    name: "Canto Testnet",
    gasPrice: 1000n * 10n ** 9n
  },
  "338": {
    name: "Cronos Testnet",
    gasPrice: 2000n * 10n ** 9n
  },
  "199": {
    name: "BitTorrent Chain",
    gasPrice: 300000n * 10n ** 9n
  },
  "88882": {
    name: "Spicy Chain",
    gasPrice: 2500n * 10n ** 9n,
    gasLimit: 200000n
  },
  "88888": {
    name: "Chiliz Chain",
    gasPrice: 2500n * 10n ** 9n,
    gasLimit: 200000n
  },
  // SKALE chains
  "1350216234": {
    name: "Titan",
    gasPrice: 110000n
  },
  "1482601649": {
    name: "Nebula",
    gasPrice: 110000n
  },
  "1564830818": {
    name: "Calypso",
    gasPrice: 110000n
  },
  "2046399126": {
    name: "Europa",
    gasPrice: 110000n
  }
};
var FACTORIES = {
  "420120000": COMMON_FACTORY_ADDRESS,
  "420120001": COMMON_FACTORY_ADDRESS,
  "88888": "0xc501b9abf5540de1dd24f66633b1ecf35ff7101f"
  // EIP155 is enforced, but the check fails, hence we hardcode the address here instead of computing dynamically
};
var CUSTOM_GAS_BINS = [
  1n,
  1n * 10n ** 9n,
  100n * 10n ** 9n,
  500n * 10n ** 9n,
  1000n * 10n ** 9n,
  2500n * 10n ** 9n,
  5000n * 10n ** 9n,
  7500n * 10n ** 9n,
  10000n * 10n ** 9n,
  25000n * 10n ** 9n,
  50000n * 10n ** 9n,
  75000n * 10n ** 9n,
  100000n * 10n ** 9n,
  250000n * 10n ** 9n,
  500000n * 10n ** 9n,
  750000n * 10n ** 9n,
  1000000n * 10n ** 9n
];

// node_modules/thirdweb/dist/esm/utils/any-evm/keccak-id.js
function keccakId(input) {
  return keccak256(stringToBytes(input));
}

// node_modules/thirdweb/dist/esm/utils/any-evm/get-salt-hash.js
function getSaltHash(bytecode) {
  const bytecodeHash = keccakId(ensureBytecodePrefix(bytecode));
  const salt = `tw.${bytecodeHash}`;
  return keccakId(salt);
}

// node_modules/thirdweb/dist/esm/utils/any-evm/compute-deployment-address.js
function computeDeploymentAddress(options) {
  const bytecode = ensureBytecodePrefix(options.bytecode);
  const saltHash = options.salt ? isHex(options.salt) && options.salt.length === 66 ? options.salt : keccakId(options.salt) : getSaltHash(bytecode);
  const initBytecode = options.extraDataWithUri ? encodePacked(["bytes", "bytes", "bytes"], [bytecode, options.encodedArgs, options.extraDataWithUri]) : encodePacked(["bytes", "bytes"], [bytecode, options.encodedArgs]);
  const deployInfoPacked = encodePacked(["bytes1", "address", "bytes32", "bytes32"], [
    "0xff",
    getAddress(options.create2FactoryAddress),
    saltHash,
    keccak256(encodePacked(["bytes"], [initBytecode]))
  ]);
  const hashedDeployInfo = keccak256(encodePacked(["bytes"], [deployInfoPacked]));
  return `0x${hashedDeployInfo.slice(26)}`;
}

// node_modules/thirdweb/dist/esm/utils/any-evm/get-init-bytecode-with-salt.js
function getInitBytecodeWithSalt(options) {
  const bytecode = ensureBytecodePrefix(options.bytecode);
  const saltHash = options.salt ? isHex(options.salt) && options.salt.length === 66 ? options.salt : keccakId(options.salt) : getSaltHash(bytecode);
  const encodedArgs = typeof options.encodedArgs === "string" ? options.encodedArgs : uint8ArrayToHex(options.encodedArgs);
  return encodePacked(["bytes32", "bytes", "bytes"], [saltHash, bytecode, encodedArgs]);
}

// node_modules/thirdweb/dist/esm/utils/signatures/resolve-signature.js
var function_cache = /* @__PURE__ */ new Map();
var event_cache = /* @__PURE__ */ new Map();
var SIGNATURE_API = "https://www.4byte.directory/api/v1";
async function resolveFunctionSignature(hexSig) {
  if (function_cache.has(hexSig)) {
    return function_cache.get(hexSig);
  }
  const res = await fetch(`${SIGNATURE_API}/signatures/?format=json&hex_signature=${hexSig}`);
  if (!res.ok) {
    return null;
  }
  const data = await res.json();
  if (data.count === 0) {
    return null;
  }
  const signature = `function ${data.results[0].text_signature}`;
  function_cache.set(hexSig, signature);
  return signature;
}
async function resolveEventSignature(hexSig) {
  if (event_cache.has(hexSig)) {
    return event_cache.get(hexSig);
  }
  const res = await fetch(`${SIGNATURE_API}/event-signatures/?format=json&hex_signature=${hexSig}`);
  if (!res.ok) {
    return null;
  }
  const data = await res.json();
  if (data.count === 0) {
    return null;
  }
  const signature = `event ${uppercaseFirstLetter(data.results[0].text_signature)}`;
  event_cache.set(hexSig, signature);
  return signature;
}
function uppercaseFirstLetter(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
async function resolveSignature(hexSig) {
  if (hexSig.startsWith("0x")) {
    hexSig = hexSig.slice(2);
  }
  const all = await Promise.all([
    resolveFunctionSignature(hexSig),
    resolveEventSignature(hexSig)
  ]);
  return {
    function: all[0],
    event: all[1]
  };
}
async function resolveSignatures(hexSigs) {
  hexSigs = Array.from(new Set(hexSigs));
  const all = await Promise.all(hexSigs.map((hexSig) => resolveSignature(hexSig)));
  return {
    functions: all.map((x) => x.function).filter((x) => x !== null).sort(),
    events: all.map((x) => x.event).filter((x) => x !== null).sort()
  };
}

// node_modules/thirdweb/dist/esm/utils/signatures/sign.js
function sign2({ hash, privateKey }) {
  const { r, s, yParity } = sign({ payload: hash, privateKey });
  return {
    r: toHex(r, { size: 32 }),
    s: toHex(s, { size: 32 }),
    v: yParity === 1 ? 28n : 27n,
    yParity
  };
}

// node_modules/thirdweb/dist/esm/utils/signatures/signature-to-hex.js
function signatureToHex(signature) {
  const { r, s, v, yParity } = signature;
  return toHex2(from(typeof yParity !== "undefined" ? {
    r,
    s,
    yParity: !validate(yParity) ? fromNumber(yParity) : yParity
  } : {
    r,
    s,
    v: !validate(v) && typeof v !== "undefined" ? fromNumber(v) : v
  }));
}

// node_modules/ox/_esm/core/AbiError.js
function decode2(abiError, data, options = {}) {
  if (size(data) < 4)
    throw new InvalidSelectorSizeError({ data });
  if (abiError.inputs.length === 0)
    return void 0;
  const values = decode(abiError.inputs, slice(data, 4), options);
  if (values && Object.keys(values).length === 1) {
    if (Array.isArray(values))
      return values[0];
    return Object.values(values)[0];
  }
  return values;
}
function from5(abiError, options = {}) {
  return from3(abiError, options);
}
function fromAbi3(abi, name, options) {
  if (name === "Error")
    return solidityError;
  if (name === "Panic")
    return solidityPanic;
  if (validate(name, { strict: false })) {
    const selector = slice(name, 0, 4);
    if (selector === solidityErrorSelector)
      return solidityError;
    if (selector === solidityPanicSelector)
      return solidityPanic;
  }
  const item = fromAbi(abi, name, options);
  if (item.type !== "error")
    throw new NotFoundError({ name, type: "error" });
  return item;
}
var solidityError = from5({
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
});
var solidityErrorSelector = "0x08c379a0";
var solidityPanic = from5({
  inputs: [
    {
      name: "reason",
      type: "uint8"
    }
  ],
  name: "Panic",
  type: "error"
});
var solidityPanicSelector = "0x4e487b71";

// node_modules/thirdweb/dist/esm/utils/abi/decodeError.js
async function decodeError(options) {
  const { contract, data } = options;
  let abi = contract == null ? void 0 : contract.abi;
  if (contract && !abi) {
    abi = await resolveContractAbi(contract).catch(() => void 0);
  }
  if (!abi) {
    throw new Error(`No ABI found for contract ${contract.address} on chain ${contract.chain.id}`);
  }
  const abiError = fromAbi3(abi, data);
  return decode2(abiError, data);
}

// node_modules/thirdweb/dist/esm/utils/abi/decodeFunctionData.js
async function decodeFunctionData(options) {
  const { contract, data } = options;
  let abi = contract == null ? void 0 : contract.abi;
  if (contract && !abi) {
    abi = await resolveContractAbi(contract).catch(() => void 0);
  }
  if (!abi) {
    throw new Error(`No ABI found for contract ${contract.address} on chain ${contract.chain.id}`);
  }
  const abiFunction = fromAbi2(abi, data);
  return decodeData(abiFunction, data);
}

// node_modules/thirdweb/dist/esm/utils/abi/decodeFunctionResult.js
async function decodeFunctionResult(options) {
  const { contract, ...rest } = options;
  let abi = contract == null ? void 0 : contract.abi;
  if (contract && !abi) {
    abi = await resolveContractAbi(contract).catch(() => void 0);
  }
  if (!abi) {
    throw new Error(`No ABI found for contract ${contract.address} on chain ${contract.chain.id}`);
  }
  const abiFunction = fromAbi2(abi, rest.data);
  return decodeResult(abiFunction, rest.data);
}

// node_modules/thirdweb/dist/esm/utils/jwt/jwt-header.js
var PRECOMPILED_B64_ENCODED_JWT_HEADER = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9";

// node_modules/thirdweb/dist/esm/utils/jwt/decode-jwt.js
function decodeJWT(jwt) {
  const [encodedHeader, encodedPayload, encodedSignature] = jwt.split(".");
  if (encodedHeader !== PRECOMPILED_B64_ENCODED_JWT_HEADER) {
    throw new Error("Invalid JWT header");
  }
  if (!encodedPayload || !encodedSignature) {
    throw new Error("Invalid JWT");
  }
  const payload = JSON.parse(base64ToString(encodedPayload));
  const signature = base64ToString(encodedSignature);
  return {
    payload,
    signature
  };
}

// node_modules/thirdweb/dist/esm/utils/jwt/encode-jwt.js
async function encodeJWT(options) {
  const payload = await ensureJWTPayload(options.payload);
  const message = stringify(payload);
  const signature = await options.account.signMessage({ message });
  const encodedData = uint8ArrayToBase64(stringToBytes(message), {
    urlSafe: true
  });
  const encodedSignature = uint8ArrayToBase64(stringToBytes(signature), {
    urlSafe: true
  });
  return `${PRECOMPILED_B64_ENCODED_JWT_HEADER}.${encodedData}.${encodedSignature}`;
}
async function ensureJWTPayload(payload) {
  return {
    iss: payload.iss,
    sub: payload.sub,
    aud: payload.aud,
    exp: Math.floor(payload.exp.getTime() / 1e3),
    nbf: Math.floor(payload.nbf.getTime() / 1e3),
    iat: Math.floor(payload.iat.getTime() / 1e3),
    // default to uuid if jti is not provided
    jti: payload.jti || await randomBytesHex(),
    ctx: payload.ctx
  };
}

// node_modules/thirdweb/dist/esm/utils/jwt/refresh-jwt.js
var DEFAULT_EXPIRATION_TIME = 60 * 60 * 24;
async function refreshJWT(options) {
  const { account, jwt, expirationTime = DEFAULT_EXPIRATION_TIME } = options;
  const payload = decodeJWT(jwt).payload;
  return encodeJWT({
    payload: {
      iss: payload.iss,
      sub: payload.sub,
      aud: payload.aud,
      nbf: /* @__PURE__ */ new Date(),
      exp: new Date(Date.now() + expirationTime),
      iat: /* @__PURE__ */ new Date(),
      ctx: payload.ctx
    },
    account
  });
}

// node_modules/thirdweb/dist/esm/utils/contract/parse-abi-params.js
function parseAbiParams(constructorParamTypes, constructorParamValues) {
  if (constructorParamTypes.length !== constructorParamValues.length) {
    throw new Error(`Passed the wrong number of constructor arguments: ${constructorParamValues.length}, expected ${constructorParamTypes.length}`);
  }
  return constructorParamTypes.map((type, index) => {
    const value = constructorParamValues[index];
    if (type === "tuple" || type.endsWith("]")) {
      if (typeof value === "string") {
        return JSON.parse(value);
      }
      return value;
    }
    if (type === "string") {
      return String(value);
    }
    if (type === "bytes32") {
      if (!isHex(value)) {
        throw new Error(`${value} is not a valid hex string`);
      }
      return padHex(value);
    }
    if (type.startsWith("bytes")) {
      if (!isHex(value)) {
        throw new Error(`${value} is not a valid hex string`);
      }
      return value;
    }
    if (type === "address") {
      if (typeof value !== "string" || !isAddress(value)) {
        throw new Error(`${value} is not a valid address`);
      }
      return value;
    }
    if (type.startsWith("uint") || type.startsWith("int")) {
      if (typeof value === "bigint") {
        return value;
      }
      if (typeof value !== "string" && typeof value !== "number") {
        throw new Error(`Cannot convert type ${typeof value} to BigInt`);
      }
      try {
        const val = BigInt(value);
        return val;
      } catch (err) {
        throw new Error(err.message);
      }
    }
    if (type.startsWith("bool")) {
      if (value === "false" || value === false) {
        return false;
      }
      if (value === "true" || value === true) {
        return true;
      }
      throw new Error("Invalid boolean value. Expecting either 'true' or 'false'");
    }
    return value;
  });
}
export {
  boolToBytes,
  boolToHex,
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  checksumAddress,
  clearTransactionDecorator,
  computeCreate2FactoryAddress,
  computeDeploymentAddress,
  concatHex,
  decodeAbiParameters,
  decodeError,
  decodeFunctionData,
  decodeFunctionResult,
  decodeJWT,
  deployCreate2Factory,
  detectMethod,
  encodeAbiParameters,
  encodeJWT,
  encodePacked,
  ensureBytecodePrefix,
  extractIPFSUri,
  extractMinimalProxyImplementationAddress,
  formatNumber,
  fromBytes2 as fromBytes,
  fromGwei,
  fromHex2 as fromHex,
  getAddress,
  getClaimParams,
  getDeployedCreate2Factory,
  getInitBytecodeWithSalt,
  getKeylessTransaction,
  getSaltHash,
  getTransactionDecorator,
  hashMessage,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isAddress,
  isBytes,
  isContractDeployed,
  isEIP155Enforced,
  isHex,
  isValidENSName,
  isZkSyncChain,
  keccak256,
  keccakId,
  max,
  maxUint256,
  min,
  numberToBytes,
  numberToHex,
  padHex,
  parseAbiParams,
  refreshJWT,
  resolveImplementation,
  resolvePromisedValue,
  resolveSignature,
  resolveSignatures,
  setServiceKey,
  setThirdwebDomains,
  setTransactionDecorator,
  sha256,
  shortenAddress,
  shortenHex,
  shortenLargeNumber,
  sign2 as sign,
  signMessage,
  signTypedData,
  signatureToHex,
  stringToBytes,
  stringToHex,
  stringify,
  toBytes,
  toEther,
  toEventSelector,
  toFunctionSelector,
  toHex,
  toTokens,
  toUnits,
  toWei,
  uint8ArrayToHex
};
//# sourceMappingURL=thirdweb_utils.js.map
