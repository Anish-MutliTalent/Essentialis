import {
  eth_getTransactionCount
} from "./chunk-P2JU2M2C.js";
import {
  eth_estimateGas
} from "./chunk-NUZ5EB3F.js";
import {
  getUser,
  signTransaction
} from "./chunk-Q7PVCN6P.js";
import {
  deploySmartAccount,
  verifyHash
} from "./chunk-G4S47F5F.js";
import {
  sha256
} from "./chunk-6IKSF6CX.js";
import {
  eth_getStorageAt
} from "./chunk-U4HHAIE3.js";
import "./chunk-2JMEOC4X.js";
import {
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  fromBytes
} from "./chunk-5T45IMNW.js";
import {
  serializeTransaction
} from "./chunk-YNTQV2T3.js";
import "./chunk-5DLV5WR6.js";
import {
  eth_getLogs,
  getBuyWithCryptoHistory,
  getContractEvents,
  isBaseTransactionOptions,
  simulateTransaction,
  watchContractEvents
} from "./chunk-QMM6P4FG.js";
import {
  getBuyWithCryptoQuote,
  getBuyWithCryptoStatus,
  getBuyWithCryptoTransfer
} from "./chunk-TFIFYE7P.js";
import {
  sendAndConfirmTransaction,
  sendBatchTransaction
} from "./chunk-UBHYE6QZ.js";
import {
  insight_exports
} from "./chunk-V6OMJ4JN.js";
import "./chunk-AP65CEI4.js";
import "./chunk-WWY7S4YD.js";
import {
  parseEventLogs,
  prepareEvent
} from "./chunk-V2KTC3TQ.js";
import "./chunk-ZDBTTMOY.js";
import {
  prepareContractCall
} from "./chunk-7WWFRKEP.js";
import "./chunk-F2HWAKON.js";
import {
  eth_blockNumber,
  eth_getTransactionReceipt,
  waitForReceipt,
  watchBlockNumber
} from "./chunk-DEON3F34.js";
import "./chunk-QWTK625L.js";
import {
  eth_getBalance
} from "./chunk-BKSLBPLK.js";
import {
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS
} from "./chunk-YCZ3YGMG.js";
import {
  sendTransaction
} from "./chunk-32UNHBSF.js";
import "./chunk-YQXA2AWL.js";
import {
  getSignPayload
} from "./chunk-RLZQZOTA.js";
import "./chunk-WQM2SOQQ.js";
import "./chunk-CQABUGWC.js";
import "./chunk-PHFEZCFB.js";
import "./chunk-V4DR3IRU.js";
import "./chunk-SWAFX6ND.js";
import {
  prepareTransaction
} from "./chunk-QGXAPRFG.js";
import {
  eth_getCode
} from "./chunk-SLZ3Y5V2.js";
import "./chunk-RNESBU4Y.js";
import {
  eth_call,
  readContract
} from "./chunk-DABXKW5Y.js";
import {
  estimateGasCost
} from "./chunk-C3UIV4TQ.js";
import {
  eth_sendRawTransaction
} from "./chunk-CMXLKATA.js";
import {
  toSerializableTransaction
} from "./chunk-5LTEBNG6.js";
import "./chunk-BIVYGU57.js";
import {
  estimateGas,
  eth_gasPrice,
  eth_getBlockByNumber,
  eth_maxPriorityFeePerGas,
  getGasPrice,
  parseAbiItem,
  resolveContractAbi
} from "./chunk-6AN5T5RL.js";
import "./chunk-MH6B2CTO.js";
import {
  fromGwei,
  toEther,
  toTokens,
  toUnits,
  toWei
} from "./chunk-HAADYJEF.js";
import {
  concatHex
} from "./chunk-C67JNMHT.js";
import {
  encode
} from "./chunk-DV4XGEHR.js";
import {
  formatBlock,
  formatTransaction
} from "./chunk-GRBRMOVF.js";
import {
  getContract
} from "./chunk-6K2H5JDO.js";
import {
  getAddress,
  isAddress,
  keccak256
} from "./chunk-VNYBYIMU.js";
import {
  boolToBytes,
  hexToBytes,
  numberToBytes,
  stringToBytes,
  toBytes
} from "./chunk-OKXYG5CJ.js";
import "./chunk-LC6YL3ZA.js";
import "./chunk-CMZAKTPA.js";
import {
  getRpcClient
} from "./chunk-UOGLDG6G.js";
import {
  stringify
} from "./chunk-2CIJO3V3.js";
import {
  boolToHex,
  fromHex,
  hexToBigInt,
  hexToBool,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isHex,
  numberToHex,
  padHex,
  stringToHex,
  toHex,
  uint8ArrayToHex
} from "./chunk-T7F22WNJ.js";
import "./chunk-I364SXDL.js";
import "./chunk-VDSMUIMW.js";
import "./chunk-HQ2F3JJN.js";
import "./chunk-QKQAKKUJ.js";
import {
  defineChain
} from "./chunk-HQXXW4RM.js";
import "./chunk-MTFDOOBS.js";
import {
  getClientFetch,
  isJWT
} from "./chunk-5V4VPUUX.js";
import {
  LruMap
} from "./chunk-PPP72TBL.js";
import "./chunk-3OXDSLPJ.js";
import "./chunk-5UJ7PIRT.js";
import {
  __export
} from "./chunk-256EKJAK.js";

// node_modules/thirdweb/dist/esm/utils/client-id.js
var cache = new LruMap(4096);
function computeClientIdFromSecretKey(secretKey) {
  if (cache.has(secretKey)) {
    return cache.get(secretKey);
  }
  const cId = sha256(stringToBytes(secretKey)).slice(2, 34);
  cache.set(secretKey, cId);
  return cId;
}

// node_modules/thirdweb/dist/esm/client/client.js
function createThirdwebClient(options) {
  const { clientId, secretKey, ...rest } = options;
  let realClientId = clientId;
  if (secretKey) {
    if (isJWT(secretKey)) {
      if (!clientId) {
        throw new Error("clientId must be provided when using a JWT secretKey");
      }
    } else {
      realClientId = clientId ?? computeClientIdFromSecretKey(secretKey);
    }
  }
  if (!realClientId) {
    throw new Error("clientId or secretKey must be provided");
  }
  return {
    ...rest,
    clientId: realClientId,
    secretKey
  };
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getBlockByHash.js
async function eth_getBlockByHash(request, params) {
  const includeTransactions = params.includeTransactions ?? false;
  const block = await request({
    method: "eth_getBlockByHash",
    params: [params.blockHash, includeTransactions]
  });
  if (!block) {
    throw new Error("Block not found");
  }
  return formatBlock(block);
}

// node_modules/thirdweb/dist/esm/rpc/actions/eth_getTransactionByHash.js
async function eth_getTransactionByHash(request, params) {
  const receipt = await request({
    method: "eth_getTransactionByHash",
    params: [params.hash]
  });
  if (!receipt) {
    throw new Error("Transaction not found.");
  }
  return formatTransaction(receipt);
}

// node_modules/thirdweb/dist/esm/bridge/index.js
var bridge_exports = {};
__export(bridge_exports, {
  Buy: () => Buy_exports,
  Sell: () => Sell_exports,
  chains: () => chains,
  routes: () => routes,
  status: () => status
});

// node_modules/thirdweb/dist/esm/bridge/Buy.js
var Buy_exports = {};
__export(Buy_exports, {
  prepare: () => prepare,
  quote: () => quote
});

// node_modules/thirdweb/dist/esm/bridge/constants.js
var UNIVERSAL_BRIDGE_URL = "https://bridge.thirdweb.com/v1";

// node_modules/thirdweb/dist/esm/bridge/Buy.js
async function quote(options) {
  const { originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, client, maxSteps } = options;
  const amount = "buyAmountWei" in options ? options.buyAmountWei : options.amount;
  const clientFetch = getClientFetch(client);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/buy/quote`);
  url.searchParams.set("originChainId", originChainId.toString());
  url.searchParams.set("originTokenAddress", originTokenAddress);
  url.searchParams.set("destinationChainId", destinationChainId.toString());
  url.searchParams.set("destinationTokenAddress", destinationTokenAddress);
  url.searchParams.set("buyAmountWei", amount.toString());
  if (maxSteps) {
    url.searchParams.set("maxSteps", maxSteps.toString());
  }
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  return {
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : void 0,
    timestamp: data.timestamp,
    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,
    steps: data.steps,
    intent: {
      originChainId,
      originTokenAddress,
      destinationChainId,
      destinationTokenAddress,
      buyAmountWei: amount,
      amount
    }
  };
}
async function prepare(options) {
  const { originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, sender, receiver, client, amount, purchaseData, maxSteps } = options;
  const clientFetch = getClientFetch(client);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/buy/prepare`);
  const response = await clientFetch(url.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: stringify({
      buyAmountWei: amount.toString(),
      originChainId: originChainId.toString(),
      originTokenAddress,
      destinationChainId: destinationChainId.toString(),
      destinationTokenAddress,
      sender,
      receiver,
      purchaseData,
      maxSteps
    })
  });
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  return {
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : void 0,
    timestamp: data.timestamp,
    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,
    steps: data.steps.map((step) => ({
      ...step,
      transactions: step.transactions.map((transaction) => ({
        ...transaction,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        client,
        chain: defineChain(transaction.chainId)
      }))
    })),
    intent: {
      originChainId,
      originTokenAddress,
      destinationChainId,
      destinationTokenAddress,
      amount
    }
  };
}

// node_modules/thirdweb/dist/esm/bridge/Sell.js
var Sell_exports = {};
__export(Sell_exports, {
  prepare: () => prepare2,
  quote: () => quote2
});
async function quote2(options) {
  const { originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, amount, client, maxSteps } = options;
  const clientFetch = getClientFetch(client);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/sell/quote`);
  url.searchParams.set("originChainId", originChainId.toString());
  url.searchParams.set("originTokenAddress", originTokenAddress);
  url.searchParams.set("destinationChainId", destinationChainId.toString());
  url.searchParams.set("destinationTokenAddress", destinationTokenAddress);
  url.searchParams.set("sellAmountWei", amount.toString());
  if (typeof maxSteps !== "undefined") {
    url.searchParams.set("maxSteps", maxSteps.toString());
  }
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  return {
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : void 0,
    timestamp: data.timestamp,
    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,
    steps: data.steps,
    intent: {
      originChainId,
      originTokenAddress,
      destinationChainId,
      destinationTokenAddress,
      amount
    }
  };
}
async function prepare2(options) {
  const { originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, amount, sender, receiver, client, purchaseData, maxSteps } = options;
  const clientFetch = getClientFetch(client);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/sell/prepare`);
  const response = await clientFetch(url.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: stringify({
      sellAmountWei: amount.toString(),
      originChainId: originChainId.toString(),
      originTokenAddress,
      destinationChainId: destinationChainId.toString(),
      destinationTokenAddress,
      sender,
      receiver,
      purchaseData,
      maxSteps
    })
  });
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  return {
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    blockNumber: data.blockNumber ? BigInt(data.blockNumber) : void 0,
    timestamp: data.timestamp,
    estimatedExecutionTimeMs: data.estimatedExecutionTimeMs,
    steps: data.steps.map((step) => ({
      ...step,
      transactions: step.transactions.map((transaction) => ({
        ...transaction,
        value: transaction.value ? BigInt(transaction.value) : void 0,
        client,
        chain: defineChain(transaction.chainId)
      }))
    })),
    expiration: data.expiration,
    intent: {
      originChainId,
      originTokenAddress,
      destinationChainId,
      destinationTokenAddress,
      amount,
      purchaseData
    }
  };
}

// node_modules/thirdweb/dist/esm/bridge/Status.js
async function status(options) {
  const { transactionHash, client } = options;
  const chainId = "chainId" in options ? options.chainId : options.chain.id;
  const clientFetch = getClientFetch(client);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/status`);
  url.searchParams.set("transactionHash", transactionHash);
  url.searchParams.set("chainId", chainId.toString());
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message} - ${errorJson.correlationId}`);
  }
  const { data } = await response.json();
  if (data.status === "FAILED") {
    return {
      status: "FAILED",
      transactions: data.transactions
    };
  }
  if (data.status === "PENDING") {
    return {
      status: "PENDING",
      originAmount: BigInt(data.originAmount),
      originChainId: data.originChainId,
      destinationChainId: data.destinationChainId,
      originTokenAddress: data.originTokenAddress,
      destinationTokenAddress: data.destinationTokenAddress,
      transactions: data.transactions
    };
  }
  if (data.status === "NOT_FOUND") {
    return {
      status: "NOT_FOUND",
      transactions: []
    };
  }
  return {
    status: "COMPLETED",
    originAmount: BigInt(data.originAmount),
    destinationAmount: BigInt(data.destinationAmount),
    originChainId: data.originChainId,
    destinationChainId: data.destinationChainId,
    originTokenAddress: data.originTokenAddress,
    destinationTokenAddress: data.destinationTokenAddress,
    transactions: data.transactions,
    purchaseData: data.purchaseData
  };
}

// node_modules/thirdweb/dist/esm/bridge/Routes.js
async function routes(options) {
  const { client, originChainId, originTokenAddress, destinationChainId, destinationTokenAddress, maxSteps, sortBy, limit, offset } = options;
  const clientFetch = getClientFetch(client);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/routes`);
  if (originChainId) {
    url.searchParams.set("originChainId", originChainId.toString());
  }
  if (originTokenAddress) {
    url.searchParams.set("originTokenAddress", originTokenAddress);
  }
  if (destinationChainId) {
    url.searchParams.set("destinationChainId", destinationChainId.toString());
  }
  if (destinationTokenAddress) {
    url.searchParams.set("destinationTokenAddress", destinationTokenAddress);
  }
  if (maxSteps) {
    url.searchParams.set("maxSteps", maxSteps.toString());
  }
  if (limit) {
    url.searchParams.set("limit", limit.toString());
  }
  if (offset) {
    url.searchParams.set("offset", offset.toString());
  }
  if (sortBy) {
    url.searchParams.set("sortBy", sortBy);
  }
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message}`);
  }
  const { data } = await response.json();
  return data;
}

// node_modules/thirdweb/dist/esm/bridge/Chains.js
async function chains(options) {
  const { client } = options;
  const clientFetch = getClientFetch(client);
  const url = new URL(`${UNIVERSAL_BRIDGE_URL}/chains`);
  const response = await clientFetch(url.toString());
  if (!response.ok) {
    const errorJson = await response.json();
    throw new Error(`${errorJson.code} | ${errorJson.message}`);
  }
  const { data } = await response.json();
  return data;
}

// node_modules/thirdweb/dist/esm/transaction/resolve-method.js
function resolveMethod(method) {
  return async (contract) => {
    var _a;
    if (typeof method === "string" && method.startsWith("function ")) {
      return parseAbiItem(method);
    }
    const resolvedAbi = ((_a = contract.abi) == null ? void 0 : _a.length) ? contract.abi : await resolveContractAbi(contract);
    const abiFunction = resolvedAbi.find((item) => {
      if (item.type !== "function") {
        return false;
      }
      return item.name === method;
    });
    if (!abiFunction) {
      throw new Error(`could not find function with name "${method}" in abi`);
    }
    return abiFunction;
  };
}

// node_modules/thirdweb/dist/esm/auth/verify-typed-data.js
async function verifyTypedData({ address, signature, client, chain, accountFactory, message, domain, primaryType, types }) {
  const messageHash = getSignPayload({
    message,
    domain,
    primaryType,
    types
  });
  return verifyHash({
    hash: messageHash,
    signature,
    address,
    chain,
    client,
    accountFactory
  });
}

// node_modules/thirdweb/dist/esm/transaction/actions/eip7702/authorization.js
async function signAuthorization(options) {
  const { account, request } = options;
  if (typeof account.signAuthorization === "undefined") {
    throw new Error("This account type does not yet support signing EIP-7702 authorizations");
  }
  return account.signAuthorization(request);
}
export {
  ZERO_ADDRESS as ADDRESS_ZERO,
  bridge_exports as Bridge,
  insight_exports as Insight,
  NATIVE_TOKEN_ADDRESS,
  ZERO_ADDRESS,
  boolToBytes,
  boolToHex,
  bytesToBigInt,
  bytesToBool,
  bytesToNumber,
  bytesToString,
  concatHex,
  createThirdwebClient,
  defineChain,
  deploySmartAccount,
  encode,
  estimateGas,
  estimateGasCost,
  eth_blockNumber,
  eth_call,
  eth_estimateGas,
  eth_gasPrice,
  eth_getBalance,
  eth_getBlockByHash,
  eth_getBlockByNumber,
  eth_getCode,
  eth_getLogs,
  eth_getStorageAt,
  eth_getTransactionByHash,
  eth_getTransactionCount,
  eth_getTransactionReceipt,
  eth_maxPriorityFeePerGas,
  eth_sendRawTransaction,
  fromBytes,
  fromGwei,
  fromHex,
  getAddress,
  getBuyWithCryptoHistory,
  getBuyWithCryptoQuote,
  getBuyWithCryptoStatus,
  getBuyWithCryptoTransfer,
  getContract,
  getContractEvents,
  getGasPrice,
  getRpcClient,
  getUser,
  hexToBigInt,
  hexToBool,
  hexToBytes,
  hexToNumber,
  hexToString,
  hexToUint8Array,
  isAddress,
  isBaseTransactionOptions,
  isHex,
  keccak256,
  numberToBytes,
  numberToHex,
  padHex,
  parseEventLogs,
  prepareContractCall,
  prepareEvent,
  prepareTransaction,
  readContract,
  resolveMethod,
  sendAndConfirmTransaction,
  sendBatchTransaction,
  sendTransaction,
  serializeTransaction,
  sha256,
  signAuthorization,
  signTransaction,
  simulateTransaction,
  stringToBytes,
  stringToHex,
  toBytes,
  toEther,
  toHex,
  toSerializableTransaction,
  toTokens,
  toUnits,
  toWei,
  uint8ArrayToHex,
  verifyTypedData,
  waitForReceipt,
  watchBlockNumber,
  watchContractEvents
};
//# sourceMappingURL=thirdweb.js.map
